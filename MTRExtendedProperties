[CmdletBinding()]
Param(
    [string]$TranscriptPath = "$env:LOCALAPPDATA\ServicePortalAgent\MTRP\Logs",
    [string]$BSName = "MTRP.Powershell.Bootstrap",
    [string]$BSVersion = "2023.6.20.2",
    [string]$BSDefinitionUri = "https://agent.rooms.microsoft.com/files/public/softwareupdates/bootstrap",
    [string]$BSDefinition = "latest.json"
)

#### DO NOT CHANGE LINE BELOW ####
[version]$scriptRevision = '2024.4.25.2' #DEVOPSLINEFINDER-SCRIPTREVISION#
#### DO NOT CHANGE LINE ABOVE ####

#region Setup
# Initial variables
Set-Variable -Name "Scope" -Value "Script"
Set-Variable -Name "ScriptName", "Script" -Value "ExtendedProperties"
Set-Variable -Name "Payload" -Value @()
Set-Variable -Name "LogPrefix" -Value { "[$(Get-Date -Format "MM/dd/yyyy HH:mm:ss")]:[$ScriptName] |" }
Set-Variable -Name "PayloadPath" -Value (Join-Path -Path $TranscriptPath -ChildPath $Script)
Set-Variable -Name "TranscriptPath" -Value (Join-Path -Path $TranscriptPath -ChildPath $Script)
Set-Variable -Name "PayloadActions" -Value {
    try {
        $EPPayload = $ScriptContext.Payload | ConvertTo-Json -Depth 6
        try {
            $PayloadOutputEnabled = (Get-ItemProperty $ScriptContext.Vars.RegDesiredSettings -ErrorAction SilentlyContinue).EnableSaveScriptOutputPayloadToFile
            if ($PayloadOutputEnabled) {
                $PayloadFile = "EPPayload_$(Get-Date -Format "yyyyMMddHHmm").json"
                $PayloadPath = Join-Path -Path $ScriptContext.PayloadPath -ChildPath $PayloadFile
                $EPPayload | Out-File $PayloadPath
                Write-MTRPLog "Exported EP Payload File: $PayloadPath"
            }
        }
        catch {
            Write-MTRPLog "Error in payload output: $($_.Exception.Message)"
        }
        Write-Output $EPPayload
    }
    catch {
        Write-MTRPLog -Exception $_
        $_
    }
}

# Transcription
try {
    if (-not (Test-Path $TranscriptPath)) { 
        New-Item -Path $TranscriptPath -ItemType Directory -Force | Out-Null
    }

    $TranscriptPath = (Start-Transcript -OutputDirectory $TranscriptPath).Path
}
catch {
    Write-Warning "Error Initializing EP Transcript"
}

# Any unhandled exceptions are trapped here and all close processes are engaged
trap {
    if ($ScriptContext.IsBootstrap) {
        $ScriptContext.TelemetryHelper.Exception = $_
        Start-MTRPBCatch
    }
    else {
        Write-Host "`n`n*************** UNEXPECTED PRE-BOOTSTRAP ERROR ***************`n`n"
        Write-Host $_.Exception
        Stop-Transcript -ErrorAction SilentlyContinue | Out-Null
    }
}
#endregion Setup

try {
    #region Bootstrap
    # Check to see if this version of the bootstrap already exists
    $GetModule = { Get-Module -Name $BSName -ListAvailable | Where-Object { $_.Version -eq $BSVersion } }
    $BSModule = &$GetModule

    if (-not $BSModule) {
        Write-Host "$(&$LogPrefix) $BSName not found. Installing..."
        $AgentContext.InstallModule($BSName, $BSVersion, "$($BSDefinitionUri)/$($BSVersion).zip")
        $BSModule = &$GetModule
    }

    if ($BSModule) {
        Write-Host "$(&$LogPrefix) Importing $BSName version $BSVersion"
        try {
            Import-Module -Name $BSName -RequiredVersion $BSVersion -Force
        }
        catch [System.IO.FileLoadException] {
            Write-Host "$(&$LogPrefix) $BSName import failed: $($_.Exception.Message)"
        }
    }
    else {
        Write-Error "$BSName ($BSVersion) installation failed"
    }

    [PSCustomObject]@{
        BootstrapDefinition    = $BSDefinition
        ScriptRevision         = $scriptRevision
        ScriptName             = $ScriptName
        BootstrapDefinitionUri = $BSDefinitionUri
        Variables              = $ScriptContext.Vars
        Scope                  = $Scope
    } | Start-MTRPBBootstrap
    #endregion Bootstrap

    #region Post Bootstrap Settings
    try {
        $featureconfig = Get-MTRPFeatureFlagConfigFromService
    }
    catch {
        Write-MTRPLog -Exception $_
    }
    
    $MTRP = $ScriptContext.TelemetryHelper
    $ScriptContext.PayloadPath = $PayloadPath
    $ScriptContextItems = $ScriptContext.GetEnumerator().Name
    $ScriptContextItems | ForEach-Object {
        $Var = Get-Variable -Name $_ -ErrorAction SilentlyContinue
        if ($Var) {
            $ScriptContext[$_] = $Var.Value
        }
    }

    #gather hardwareinfo for use throughout the script
    $mtrpPNPHardwareInfo = Get-MTRPPnPHardwareInfo
    #endregion Post Bootstrap Settings

    #region Run EP
    Write-MTRPLog "Namespace: Helper Functions"
    #region Helper Functions
    function Send-IoTHubEvent {
        param(
            $Name,
            [hashtable]$Data
        )
        try {
            if (!$script) { $script = "Unknown" }
            $hash = @{
                Script = $Script
            }
            if ($Data) {
                foreach ($item in $data.GetEnumerator()) {
                    $hash.Add($item.Name, $item.Value)
                }
            }
            $AgentContext.SendIotHubEvent($Name, $hash);
        }
        catch {
            Trace-MTRPException $_
        }
    }

    
    function GetTaskStatus($trackingRegPath, $stepName) {
        $stepPath = (join-path $trackingRegPath $stepName)
        if ((Test-Path $stepPath) -eq $false) {
            New-Item -Path $stepPath -Force | out-null
        }
        $stepStatus = (Get-ItemProperty -Path $stepPath).Status
        $stepTime = (Get-ItemProperty -Path $stepPath).Time
        $stepCount = (Get-ItemProperty -Path $stepPath).Count
        if ($null -eq $stepStatus) {
            New-ItemProperty -Path $stepPath -Name "Status" -Force -Value "init" | out-null
            New-ItemProperty -Path $stepPath -Name "Time" -Force -Value (Get-date -format "MM/dd/yyyy HH:mm:ss") | out-null
            New-ItemProperty -Path $stepPath -Name "Count" -Force -Value 0 | out-null
            return @{status = "init"; lastrun = $null; count = 0 }
        }
        else {
            return @{
                status   = $stepStatus;
                lastrun  = $stepTime
                runcount = $stepCount;
            }
        }
    }
    function SetTaskStatus($trackingRegPath, $stepName, $statusValue) {
        $stepPath = (join-path $trackingRegPath $stepName)
        $stepStatus = (Get-ItemProperty -Path $stepPath).Status
        if ($null -eq $stepStatus) {
            New-ItemProperty -Path $stepPath -Name "Status" -Force -Value $statusValue | out-null
            New-ItemProperty -Path $stepPath -Name "Time" -Force -Value (Get-date) | out-null
            New-ItemProperty -Path $stepPath -Name "Count" -Force -Value 1 | out-null
        }
        else {
            $runCount = (Get-ItemProperty -Path $stepPath).Count;
            if ($null -eq $runCount) {
                $runCount = 0;
            }
            Set-ItemProperty -Path $stepPath -Name "Status" -Value $statusValue | out-null
            New-ItemProperty -Path $stepPath -Name "Time" -Force -Value (Get-date) | out-null
            New-ItemProperty -Path $stepPath -Name "Count" -Force -Value ($runCount + 1) | out-null
        }
    }
    
    function Get-FileContent ($FIle) {
        $content = $null
        try {
            if (Test-Path $file) {
                $content = get-content $file
            }
            else {
                Trace-MTRPTrace "Cannot get content from $file"
            }
        }
        catch { Trace-MTRPException }
        return $content
    }
    function GetRegValue {
        param($Path, $Name)
        $output = $null
        Trace-MTRPTrace "Looking for reg value for $Name"
        try {
            $result = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue
            if ($result) {
                Trace-MTRPTrace "Found reg value for $Name"
                $value = $result.$($Name)
            }
        }
        catch {
            Trace-MTRPTrace $_.Exception.Message
        }
        if ($null -ne $value) {
            $output = $value
        }
        else {
            Trace-MTRPTrace "No value value found at path $path for item name $name"
        }
        return $output
    }
    #endregion Helper Functions

    Write-MTRPLog "Namespace: Maintenance Functions"
    #region Maintenance Functions
    function Start-ProcessMTRModelHits {
        param (
            [switch]$TestRun
        )
        try {
            Trace-MTRPTrace "Processing MTR Model hits"
            $topModel = "TBD"
            #this will only run 1 time per day
            $lastRun = Get-MTRPAgentData -KeyName 'MTRModelHitsRunTime'
            if ($lastRun) {
                $runTime = New-TimeSpan -Start $lastRun -End (Get-Date)
                Trace-MTRPTrace "ProcessMTRModelHits Last Run Time: $lastRun"
                if (!$TestRun) {
                    if ($runTime.TotalMinutes -lt 720) {
                        Trace-MTRPTrace "Not processing models since it has not been 12 hours since last time"
                        try {
                            $dailyTopModelArray = Get-MTRPAgentData -KeyName 'MTRDailyModelData'
                            if ($null -ne $dailyTopModelArray) {
                                $jsonString = ConvertTo-Json $dailyTopModelArray
                                Trace-MTRPTrace "Current DailyTopModelTracker: $jsonString"
                            }
                        }
                        catch {
                            Trace-MTRPException $_
                        }
                        return $topModel
                    }
                }
                else {
                    Trace-MTRPTrace "TestRun switch is detected, bypassing 24 re-run time"
                }
            }
            #because the Model decision is based on various hardware items that may are may not be connected because of actual connection issues
            # we use this function to make a better choice. This will pick the highest count hit model from the MTRModelHits tracker.
            #after a high hitter has been consistent for 7 or more total times (dont have to be in a row), it will be reported to EP and saved as the model.
            #first make sure we havent already marked it as a specific model, otherwise move on
            $MTRModelName = GetRegValue -Path "HKLM:\Software\Microsoft\MTRP" -Name "MTRModelName"
            #$topModelTracker = Get-MTRPAgentData -KeyName 'MTRModelFinal'
            if ($null -eq $MTRModelName) {
                $ModelHitsArray = Get-MTRPAgentData -KeyName 'MTRModelHitsData'
                if ($null -ne $ModelHitsArray) {
                    Trace-MTRPTrace "Models: $($ModelHitsArray.Model) HitCounts: $($ModelHitsArray.HitCount)"
                    $topModelName = ($ModelHitsArray | Sort-Object HitCount -Descending | Select-Object -First 1).Model
                    $topModelHitCount = ($ModelHitsArray | Sort-Object HitCount -Descending | Select-Object -First 1).HitCount
                    Trace-MTRPTrace "Current MTR Model top hitter: $topModelName Count: $topModelHitCount"
                    #get the daily top hitter tracker
                    $dailyTopModelArray = Get-MTRPAgentData -KeyName 'MTRDailyModelData'
                    if ($null -ne $dailyTopModelArray -and $topModelName -ne "Unknown") {
                        Trace-MTRPTrace "DailyModels: $($dailyTopModelArray.Model) DailyHitCounts: $($dailyTopModelArray.HitCount)"
                        if ($dailyTopModelArray.Model -like $topModelName) {
                            #looks like this has been a daily top hitter before, if it is already at 7, report it as the model otherwise add 1 to its count
                            $thisModel = $dailyTopModelArray | Where-Object Model -eq $topModelName
                            if ($thisModel.HitCount -ge 7) {
                                New-ItemProperty -Path "HKLM:\Software\Microsoft\MTRP" -Name "MTRModelName" -Value $thisModel.Model -Force
                                #Save-MTRPAgentData -KeyName 'MTRModelFinal' -value $thisModel.Model -ttlDays 100
                                $topModel = $thisModel.Model
                                Trace-MTRPTrace "An MTR Model name has been identified and stored as: $topModel"
                                Trace-MTRPEvent "$($Script):MTRTopModel:Recorded"
                            }
                            else {
                                $thisModel.HitCount = ($thisModel.HitCount) + 1
                                Trace-MTRPTrace "$topModelName is a daily top hitter again! New total times this model has been the daily top hitter: $($thisModel.HitCount)"
                                Save-MTRPAgentData -KeyName 'MTRDailyModelData' -value $dailyTopModelArray -ttlDays 10
                            }
                        }
                        else {
                            #this daily top hitter hasnt been a top hitter before so, if there hasnt already been a model hit 7 daily times, add it to the list
                            $highestDailyHitterHitTimes = ($dailyTopModelArray | Sort-Object HitCount -Descending | Select-Object -First 1).HitCount
                            Trace-MTRPTrace "New Daily Top Hitter: $topModelName HitCount: $highestDailyHitterHitTimes"
                            if ($highestDailyHitterHitTimes -lt 7) {
                                if ($dailyTopModelArray -isnot [Array]) {
                                    $NewdailyTopModelArray = @()
                                    $NewdailyTopModelArray += $dailyTopModelArray
                                    $dailyTopModelArray = $NewdailyTopModelArray
                                }
                                Trace-MTRPTrace "No MTR Model has been a top daily hitter 7 times"
                                $newDailyModel = [PSCustomObject]@{
                                    Model    = $topModelName
                                    HitCount = 1
                                }
                                $dailyTopModelArray += $newDailyModel
                                Save-MTRPAgentData -KeyName 'MTRDailyModelData' -value $dailyTopModelArray -ttlDays 10
                            }
                            else {
                                Trace-MTRPTrace "This system has already been marked with an MTR model"
                            }
                        }
    
                    }
                    elseif ($topModelName -eq "Unknown") {
                        Trace-MTRPTrace "Current Model Top hitter is Unknown, so we dont wont to count that"
                    }
                    else {
                        #looks like this is the first time the daily top hitter check has ran so create it
                        Trace-MTRPTrace "Creating DailyTopModelTracker"
                        $dailyTopModelArray = @()
                        $modelObj = [PSCustomObject]@{
                            Model    = $topModelName
                            HitCount = 1
                        }
                        $dailyTopModelArray += $modelObj
                        Save-MTRPAgentData -KeyName 'MTRDailyModelData' -value $dailyTopModelArray -ttlDays 10
                    }
                }
                else {
                    Trace-MTRPTrace "No ModelHitsTracker found"
                }
            }
            else {
                Trace-MTRPTrace "MTR Model: $MTRModelName"
                $topModel = $MTRModelName
            }
            Save-MTRPAgentData -KeyName 'MTRModelHitsRunTime' -value (get-date) -ttlDays 10
        }
        catch {
            Trace-MTRPEvent "$($script):ProcessMTRModels:Fail"
            Trace-MTRPException $_
        }
        return $topModel
    
    }
    #region Cleanup Crestron Install Firmware
    function Start-CrestronFWInstallCleanup {
    
        Start-MTRPScriptOp -Name "CrestronFWInstallCleanup" -Type "process"
    
        $checkCrestron = (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\Firmware" -ErrorAction SilentlyContinue).Version
    
        if ($checkCrestron) {
            
            try {
            
                $CrestronInstallState = "Installed"
                $CrestronPackageFolder = "C:\Rigel\Downloads\CCS400\"
                $trackingRegPath = 'HKLM:\Software\Microsoft\MTRP\Updates\'
                $InstallState = GetRegValue $trackingRegPath 'CrestronFlexInstallState'
                $keyCcs400Maintenance = "HKLM:\SOFTWARE\Microsoft\SkypeRoomSystem\MaintenanceTasks\CCS400"
                #$keySkypeMaintenance = 'HKLM:\SOFTWARE\Microsoft\SkypeRoomSystem\MaintenanceTasks'
                if ($InstallState -eq "Staged") {
                    Trace-MTRPTrace "Device is staged for Crestron firmware update"
                    $CrestronFlexVerBeforeUpdate = GetRegValue $trackingRegPath 'CrestronFlexVerBeforeUpdate'
                    $CrestronFlexTargetVerPostUpdate = GetRegValue $trackingRegPath 'CrestronFlexTargetVerPostUpdate'
                    
                    if ($checkCrestron -eq $CrestronFlexTargetVerPostUpdate) {
                        Trace-MTRPTrace "Crestron Firmware was successfully installed. Version before update: $($CrestronFlexVerBeforeUpdate) Current version: $($checkCrestron) Target version: $($CrestronFlexTargetVerPostUpdate)...proceeding with cleanup."
                        
                        if (Test-Path $CrestronPackageFolder) {
                            Remove-Item $CrestronPackageFolder -Recurse -Force -ErrorAction SilentlyContinue
                        } 
            
                        $Crestron400Key = Test-Path $keyCcs400Maintenance
                        if ($Crestron400Key) {
                            Remove-Item -Path $keyCcs400Maintenance -Recurse -Force -ErrorAction SilentlyContinue
                        }
        
                        Set-itemproperty -path $trackingRegPath -name 'CrestronFlexInstallState' -Value $CrestronInstallState -force;
        
            
                    }
                
                }
        
            }
            catch {
                Trace-MTRPException $_
                Stop-MTRPScriptOp -Name "CrestronFWInstallCleanup" -Success $false -ResultMessageorCode $_.Exception.Message 
            }
    
        } 
        
        
        Stop-MTRPScriptOp -Name "CrestronFWInstallCleanup" -Success $true | Out-Null
    
    }
    #endregion
    Function Get-NucHdmiFirmwareVersions {
        <#
        .SYNOPSIS
        Runs the Intel NUC Bobcat tool to read the Intel NUC HDMI firmware versions on Intel Bean Canyon NUCs
        .DESCRIPTION
        Once it runs the Bobcat tool, it parses the output to return a custom object which is stored in the MTRP registry path. 
        EP then runs on schedule to read the information stored in registry. 
        .NOTES
        This was modified with new exit codes to catch various exceptions in the parsing and/or execution of Bobcat tool.
        #>
        Try {
            $outputObj = [PSCustomObject][ordered]@{
                NucHdmiFirmwareVersion     = $null
                NucHdmiFirmwareVersionCMDB = $null
                BobcatAppVersion           = $null
                IntelNUCHDMIVersion        = $null
                ParseResults               = "FailedToRun"
                Raw                        = $null
            }
            if ((Get-CimInstance Win32_BIOS).SMBIOSBIOSVersion -notlike "BEC*") {
                Trace-MTRPTrace "Not a Bean NUC, so skipping HDMI firmware check"
                $outputObj.ParseResults = 'NA'
                return $outputObj
            }
            Start-MTRPScriptOp -Name "Get-NucHdmiFirmwareVersions" -Type "process" | Out-Null
    
            Set-Variable -Name "NucHdmiFirmwareTrackingRegPath" -value 'HKLM:\Software\Microsoft\MTRP\DeviceInfo\'
            Set-Variable -Name "NucHdmiFirmwareMaintenancePath" -Value "C:\WINDOWS\ServiceProfiles\LocalService\AppData\Local\ServicePortalAgent\MTRP\Maintenance\NucHdmiFirmware"
            Set-Variable -Name "NucHdmiFirmwareRunPath" -Value "C:\Windows\ServiceProfiles\LocalService\AppData\Local\ServicePortalAgent\MTRP\Maintenance\NucHdmiFirmware\NUC8ixBE-HDMI-FW-1.77.03\BobcatISP.exe"
            Set-Variable -Name "NucHdmiFirmwareDownloadPath" -Value "C:\Rigel\Downloads\NucHdmiFirmware\"
            Set-Variable -Name "PackageZipName" -Value "NUC8ixBE-HDMI-FW-1.77.03.zip"
            Set-Variable -Name "FileName" -Value "BobcatISP.exe"
            Set-Variable -Name "NucHdmiFirmwarePackageURL" -Value "https://agent.rooms.microsoft.com/files/public/softwareupdates/util/logitech/NUC8ixBE-HDMI-FW-1.77.03.zip"
            #this will create all the keys as well
            GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'NucHdmiFirmwareVersion'
            GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'NucHdmiFirmwareVersionCMDB'
            GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'BobcatAppVersion'
            GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'IntelNUCHDMIVersion'
            GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'ParseResults'
            If (!(test-path $NucHdmiFirmwareMaintenancePath)) {
                New-Item -Path $NucHdmiFirmwareMaintenancePath -ItemType directory
            }
            Trace-MTRPTrace "Checking if updater is downloaded"
            If (!(Test-Path $NucHdmiFirmwareRunPath)) {
                Trace-MTRPTrace "NUC HDMI Firmware updater not found attempting to download"
                New-Item -Path $NucHdmiFirmwareDownloadPath -ItemType directory -Force
                Start-MTRPDownload -Source $NucHdmiFirmwarePackageURL -Destination $NucHdmiFirmwareDownloadPath
                Expand-MTRPZip -Path (join-path $NucHdmiFirmwareDownloadPath $PackageZipName) -DestinationPath $NucHdmiFirmwareMaintenancePath
                Remove-Item -Path $NucHdmiFirmwareDownloadPath -Recurse -Force
            }
            If (Test-Path $NucHdmiFirmwareRunPath) {
                Trace-MTRPTrace "Running NUC Firmware tool to get firmware version"
                $NucHdmiFirmwareOutput = & $NucHdmiFirmwareRunPath -chipinfo
                $outputObj.Raw = $NucHdmiFirmwareOutput
            }
            Else {
                $NucHdmiFirmwareOutput = $null
                Trace-MTRPTrace "NUC firmware tool download failed"
            }
    
            If ($null -ne $NucHdmiFirmwareOutput) {
                Trace-MTRPtrace ($NucHdmiFirmwareOutput | Out-string)
                If (($NucHdmiFirmwareOutput -is [array]) -and ($NucHdmiFirmwareOutput.Length -ge 9)) {
                    If ($NucHdmiFirmwareOutput[2] -eq "Graphics adapter initialization done but connection failed!") {
                        #this can happen when nothing is connected and active (even most display sleep states is active) to the HDMI port or something is wrong with the HDMI chip/firmware
                        Trace-MTRPTrace "Firmware tool ran but unable to connect to device"
                        $outputObj.ParseResults = 'ConnectionFailed' #previously NoDeviceFound
                    }
                    Elseif ($NucHdmiFirmwareOutput[6] -like "Current on-board F/W Version*") {
                        #success, parse out just the version
                        Try {
                            Trace-MTRPtrace "Trying to parse the NUC HDMI Fimware"
                            $outputObj.NucHdmiFirmwareVersion = $NucHdmiFirmwareOutput[10].split(':')[3].TrimEnd(')').trimStart(' ')
                            $IntelNUCHHDMIVersionSplit = $NucHdmiFirmwareOutput[6].split("")
                            $outputObj.IntelNUCHDMIVersion = $IntelNUCHHDMIVersionSplit[7].substring(1)
                            $outputObj.NucHdmiFirmwareVersionCMDB = $NucHdmiFirmwareOutput[10]
                            $outputObj.BobcatAppVersion = $NucHdmiFirmwareOutput[6]
                            $outputObj.ParseResults = 'VersionFound'
                        }
                        Catch {
                            Trace-MTRPTrace "Failed to parse HDMI versions correctly"
                            $outputObj.ParseResults = 'ParseException'
                        }
                    }
                    elseif ($NucHdmiFirmwareOutput[2] -eq "Graphics adapter initialization failed!") {
                        Trace-MTRPtrace "Firmware tool ran but adapter initialization failed"
                        $outputObj.ParseResults = 'InitializationFailed'
                    }
                    else {
                        Trace-MTRPtrace "Firmware tool ran but the output is not expected"
                        $outputObj.ParseResults = 'UnexpectedOutput'
                    }
                }
                Else {
                    Trace-MTRPTrace "Output is too short"
                    $outputObj.ParseResults = 'ShortOutput'
                }
            }
            else {
                Trace-MTRPTrace "NUC HDMI firmware tool output is null"
                $outputObj.ParseResults = 'OutputNull'
            }
            Stop-MTRPScriptOp -Name "Get-NucHdmiFirmwareVersions" -Success $true
        }
        Catch {
            Trace-MTRPException $_
            Stop-MTRPScriptOp -Name "Get-NucHdmiFirmwareVersions" -Success $false
        }
        SetTaskStatus $NucHdmiFirmwareTrackingRegPath 'NucHdmiFirmwareVersion' ($outputObj.NucHdmiFirmwareVersion)
        SetTaskStatus $NucHdmiFirmwareTrackingRegPath 'NucHdmiFirmwareVersionCMDB' ($outputObj.NucHdmiFirmwareVersionCMDB)
        SetTaskStatus $NucHdmiFirmwareTrackingRegPath 'BobcatAppVersion' ($outputObj.BobcatAppVersion)
        SetTaskStatus $NucHdmiFirmwareTrackingRegPath 'IntelNUCHDMIVersion' ($outputObj.IntelNUCHDMIVersion)
        SetTaskStatus $NucHdmiFirmwareTrackingRegPath 'ParseResults' ($outputObj.ParseResults)
        return $outputObj
    }
      
    Function Invoke-DiskScan() {
        $trackingRegPath = "HKLM:\Software\Microsoft\MTRP\Maintenance\";
        #Only run once a day minus window width
        GetTaskStatus $trackingRegPath 'DiskScan'
        $lastrun = (GetTaskStatus $trackingRegPath 'DiskScan').lastrun
        $status = (GetTaskStatus $trackingRegPath 'DiskScan').status
        if (($status -eq "init") -or ($lastrun -le (Get-Date).AddHours(-21))) {
            try { $op = Start-MTRPScriptOp -Name "DiskScan" -Type "Process" }catch {}
            try {
                SetTaskStatus $trackingRegPath 'DiskScan' 'Running'
                Trace-MTRPTrace 'Running Disk Scan'
                $scan = Repair-WindowsImage -ScanHealth -Online
                SetTaskStatus $trackingRegPath 'DiskScan' $scan.ImageHealthState
                try { Stop-MTRPScriptOp -Name "DiskScan" -Success $true }catch {}
            }
            catch {
                try { Stop-MTRPScriptOp -Name "DiskScan" -Success $false }catch {}
            }
            
        }
        else {
            Trace-MTRPTrace 'Already Scanned Disk Today'
        }
    }
    
    Function Invoke-SetupDiag() {
        $trackingRegPath = "HKLM:\Software\Microsoft\MTRP\Maintenance\";
        $taskName = "SetupDiag"
        #Only run once a day minus window width
        GetTaskStatus $trackingRegPath $taskName
        $lastrun = (GetTaskStatus $trackingRegPath $taskName).lastrun
        $status = (GetTaskStatus $trackingRegPath $taskName).status
        if (($status -eq "init") -or ($lastrun -le (Get-Date).AddHours(-21))) {
            try { $op = Start-MTRPScriptOp -Name $taskName -Type "Process" }catch {}
            try {
                $diagPath = "C:\Rigel\Downloads\SetupDiag.exe"
                If (!(Test-Path $diagPath)) {
                    Trace-MTRPTrace 'Downloading SetupDiag.exe'
                    $downloadPath = "C:\Rigel\Downloads\"
                    if (-not (Test-Path $downloadPath)) { New-Item -Path $downloadPath -ItemType Directory -Force | Out-Null }
                    Start-MTRPDownload -source 'https://agent.rooms.microsoft.com/files/public/softwareupdates/util/SetupDiag.exe' -Destination $downloadPath  
                }
                if (Test-Path $diagPath) {
                    SetTaskStatus $trackingRegPath $taskName 'Running'
                    Trace-MTRPTrace 'Running SetupDiag'
                    $loggingPath = "C:\Rigel\Temp\Logging"
                    if (-not (Test-Path $loggingPath)) { New-Item -Path $loggingPath -ItemType Directory -Force | Out-Null }
                    Start-Process $diagPath -ArgumentList "/Output:$loggingPath\SetupDiag.JSON /Format:json /ZipLogs:False" -NoNewWindow -Wait
                    SetTaskStatus $trackingRegPath $taskName "Complete"
                    try { Stop-MTRPScriptOp -Name $taskName -Success $true }catch {}
                }
                else {
                    Trace-MTRPException "Could Not Download SetupDiag.exe"
                }
            }
            catch {
                try { Stop-MTRPScriptOp -Name $taskName -Success $false -ResultMessageOrCode $_.Exception.Message }catch {}
            }
            
        }
        else {
            Trace-MTRPTrace 'Already ran SetupDiag.exe today'
        }
    }
    
    
    function SetAdalLoggingTeams {
        $hookPath = "C:\Users\Skype\AppData\Local\Packages\Microsoft.SkypeRoomSystem_8wekyb3d8bbwe\LocalCache\Roaming\Microsoft\Teams\hooks.json"
        if (!(Test-Path -path  $hookPath)) {
            New-item -Path  $hookPath -Type File -Force
            Set-Content -Path  $hookPath -Value '{"enableSsoLog":true,"loggingConstants":{"fileLogLevel":5},"enableUncaughtExceptionLogging":true}'
            Trace-MTRPEvent "EnableADALLogging"
        }    
    }
    function cleanUpManifestDownloads {
        Try {
            $files = Get-ChildItem 'C:\Service_Portal_Agent\ManifestDownloadFiles\' -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt (Get-date).AddDays(-1) }
            foreach ($file in $files) {
                Remove-Item $file.Fullname -Recurse -Force -ErrorAction SilentlyContinue
            }
        }
        catch {
            Trace-MTRPTrace "cleanupManifestDownloads error: $_"
        }
    }
    function Set-AudioDuckingPref {
        try {
            #set the audio settings. This tells Windows not to lower the speaker volume when in a call which makes HDMI Ingest audio very low in-room.
            $skypeUserRegPath = Get-MTRPSkypeUserRegPath
            if ([string]::IsNullOrEmpty($skypeUserRegPath)) {
                #Local 'Skype' was not found on the device
                return;
            }

            if (Test-Path $skypeUserRegPath) {
                #Skype User reg hive is currently loaded (Skype is signed in)
                $audioRegPath = "$($skypeUserRegPath)Software\Microsoft\Multimedia\Audio"
                if (!(Test-Path $audioRegPath)) {
                    New-Item -Path $audioRegPath -Force
                }
                # 0 = Mute all other sounds, 1 = Reduce all other by 80%, 2 = Reduce all other by 50%, 3 = Do nothing
                $name = "UserDuckingPreference"
                $prevValue = (Get-ItemProperty -Path $audioRegPath -Name $name -ErrorAction SilentlyContinue).UserDuckingPreference
                if ($prevValue -ne 3) {
                    $itemUpdate = New-ItemProperty -Path $audioRegPath -Name $name -Value 3 -Force
                    Trace-MTRPTrace "Set $name to value $($itemUpdate.$name)"
        
                    $audioDuckRegPath = 'HKLM:\Software\Microsoft\MTRP\DeviceInfo\'
                    if ((GetTaskStatus $audioDuckRegPath 'PreviousUserDuckingPreference').Status -eq "init") {
                        SetTaskStatus $audioDuckRegPath 'PreviousUserDuckingPreference' $prevValue
                    }
                }
            }
            else {
                Trace-MTRPTrace "Skype user is currently not signed in ($skypeUserRegPath is not found). Skipping Set-AudioDuckingPref"
            }
        }
        catch {
            Trace-MTRPException $_
        }
    }

    function Enable-CrestronUpgradeDevice {
        #this will diable the software device Crestron uses as a WU driver pointer for their main package updates
        try {
            $pnpDevice = Get-PnpDevice -FriendlyName "Crestron Upgrade Device" -ErrorAction SilentlyContinue
            if ($pnpdevice -and ($pnpDevice.Status -ne "OK")) {
                Trace-MTRPTrace "Enabling Crestron Upgrade Device"
                $pnpDevice | Enable-PnpDevice -Confirm:$false
            }
        }
        catch {
            Trace-MTRPException $_
        }
    }

    function Update-WebView2 {
        try {
            $currentVersion = $null
            #get the current version of the WebView2 runtime
            $webview2Reg = Get-ItemProperty -Path 'HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\Clients\{F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}' -Name pv -ErrorAction SilentlyContinue
            [version]$currentVersion = $webview2Reg.pv
            if ($currentVersion -ge [version]"124.0.2478.51") {
                Write-MTRPLog  "WebView2 runtime $($currentVersion) is up to date. No Action will be taken"
            }
            else
            {
                $installerArgs = @(
                    '/silent',
                    '/installSource',
                    'MicrosoftTeamsRoomsPro',
                    '/install',
                    '"appguid={F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}&appname=Microsoft%20Edge%20Webview2%20Runtime&needsadmin=prefers"'
                 )
                if ($null -ne $currentVersion) {
                    Write-MTRPLog "Current WebView2 runtime version: $currentVersion"
                }
                if ($null -eq $currentVersion) {
                    Write-MTRPLog  "WebView2 runtime is not found"
                }
                Write-MTRPLog  "Downloading WebView2 runtime"
                $downloadPath = "C:\Rigel\Downloads\"
                $webView2Path = "$downloadPath\MicrosoftEdgeUpdateSetup_X86_1.3.185.29.exe"
                if (!(Test-Path $downloadPath)) { New-Item -Path $downloadPath -ItemType Directory -Force | Out-Null }
                $resultPublic = Start-MTRPDownload -source 'https://msedge.sf.dl.delivery.mp.microsoft.com/filestreamingservice/files/4d6076eb-9605-4ec8-9571-39d3b988e526/MicrosoftEdgeUpdateSetup_X86_1.3.185.29.exe' -Destination $webView2Path
                if (Test-Path $webView2Path){
                    # Test if $webview2Path is an executable
                    $bytes = Get-Content -Path $webView2Path -Encoding Byte -TotalCount 2
                    $hex = [System.BitConverter]::ToString($bytes) -replace '-', ''
                    if ($hex -eq '4D5A') {
                        Write-MTRPLog "File is an executable"
                        $isExecutable = $true
                    } else {
                        Write-MTRPLog "File is not an executable"
                        $isExecutable = $false
                    }
                    # test if the executable is digitally signed
                    $certificate = Get-AuthenticodeSignature -FilePath $webView2Path -ErrorAction SilentlyContinue
                    if ($certificate.Status -eq [System.Management.Automation.SignatureStatus]::Valid) {
                        Write-MTRPLog "File is digitally signed."
                        Write-MTRPLog "Signer: $($certificate.SignerCertificate.Subject)"
                        $hasDigitalSignature = $true
                    } else {
                        Write-MTRPLog "File is not digitally signed."
                        $hasDigitalSignature = $false
                    }
                }
                if ($resultPublic.success -eq $false -or !$isExecutable -or !$hasDigitalSignature) {
                    Write-MTRPLog "Failed to download the WebView2 runtime from the public link, trying our blob storage"
                    $resultBlob = Start-MTRPDownload -source 'https://agent.rooms.microsoft.com/files/public/softwareupdates/binaries/edge/MicrosoftEdgeUpdateSetup_X86_1.3.185.29.exe' -Destination $webView2Path
                }
                if (($resultPublic.success -eq $true -or $resultBlob.success -eq $true) -and (Test-Path $webView2Path)) {
                    Write-MTRPLog "Installing WebView2 runtime"
                    Start-Process -FilePath $webView2Path -ArgumentList $installerArgs -Wait
                } else {
                    Write-MTRPLog "Failed to download the WebView2 runtime"
                }
                #verify the version updated correctly
                Write-MTRPLog "Verifying WebView2 runtime version was updated"
                $webview2RegNew = Get-ItemProperty -Path 'HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\Clients\{F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}' -Name pv -ErrorAction SilentlyContinue
                [version]$newVersion = $webview2RegNew.pv
                if ($newVersion -gt $currentVersion) {
                    Write-MTRPLog "WebView2 runtime updated from $currentVersion to version: $newVersion"
                } else {
                    Write-MTRPLog "Failed to update WebView2 runtime"
                }
            }
        } catch {
            Write-MTRPLog -Exception $_
        }
    }
    #endregion Maintenance Functions
    
    Write-MTRPLog "Namespace: Maintenance Actions in Window"
    #region Maintenance Actions in Window
    #try { $op = Start-MTRPScriptOp -Name "Maintenance" -Type "Process" }catch {}
    $MTRP.StartTelemetry("Maintenance", "Process")
    #check for force key
    try{
    # Calling Get-MTRPRegValuewith -silent switch, to avoid logging errors if the key is not present
    $ForceNightlyTasks = (Get-MTRPRegValue -path 'HKLM:\Software\Microsoft\MTRP' -Name 'ForceNightlyTasks' -silent) -eq '1'}
    catch{
        Write-MTRPLog "Error checking ForceNightlyTasks: $_"
    }
    # Check if we are in maintenance window
    $maintWindow = Get-MTRPMaintenanceWindow
    
    if ($maintWindow -eq "EarlyWindow" -or $maintWindow -eq "LateWindow" -or $ForceNightlyTasks) {
        if ($ForceNightlyTasks) {
            Trace-MTRPTrace "ForceNightlyTasks switch detected"
        }
        Trace-MTRPTrace "Starting Maintenance Tasks"
        #try { Start-ProcessMTRModelHits | Out-Null } catch { Trace-MTRPException $_ }
        try { Invoke-DiskScan }catch { Trace-MTRPException $_ }
        try { Invoke-SetupDiag }catch { Trace-MTRPException $_ }
        try { Invoke-MTRPEPLogiProductFirmwareVersionDiscovery Meetup | Out-Null }catch { Trace-MTRPException $_ }
        try { Get-NucHdmiFirmwareVersions }catch { Trace-MTRPException $_ }
        try { Invoke-MTRPEPLogiRallyFirmwareInfoDiscovery | Out-Null }catch { Trace-MTRPException $_ }
        try { Start-CrestronFWInstallCleanup }catch { Trace-MTRPException $_ }
        try { Invoke-MTRPEPLogiProductFirmwareVersionDiscovery Brio | Out-Null }catch { Trace-MTRPException $_ }
        try { Invoke-MTRPEPLogiProductFirmwareVersionDiscovery c930e | Out-Null }catch { Trace-MTRPException $_ }
        try { Invoke-MTRPEPLogiProductFirmwareVersionDiscovery PtzPro2 | Out-Null }catch { Trace-MTRPException $_ }
        try { Disable-MTRPWindowsService -Service @("spooler") }catch { Trace-MTRPException $_ } 
        try { Set-MTRPModernAppUpdates }catch { Trace-MTRPException $_ }          
        try { Invoke-MTRPFolderCleanUp }catch { Trace-MTRPException $_ }      
        try { Reset-MTRPEPWMIRepository | Out-Null } catch { Trace-MTRPException $_ }
        Update-WebView2 #already has try catch inside
    }
    else {
        Trace-MTRPTrace "Outside of maintenance window"
    }
    #endregion Maintenance Actions in Window

    Write-MTRPLog "Namespace: Maintenance Actions Any Time"
    #region Maintenance Actions Any Time

    #try { Stop-MTRPScriptOp -Name "Maintenance" -Success $true }catch {}
    # Temporary fix to remove cached manifest runner scripts to prevent agent from running old data
    cleanUpManifestDownloads
    
    #endregion Maintenance Actions Any Time


    #region T.Device.Network.SyntheticQualityTest_B Namespace
    Write-MTRPLog "Namespace: T.Device.Network.SyntheticQualityTest_B"
    try{
        if(Test-MTRPFeatureFlag -featureName "Network-Test-V2" -predicate $MTRPID -config $featureconfig){
            $SyntheticCallRunsSkipped = $AgentContext.GetData("SyntheticCallRunsSkipped")
            $appState = (Get-MTRPMTRAppStatus -ErrorAction SilentlyContinue | ConvertFrom-Json).response.data.currentState.status.appState
            if (((get-random -InputObject (1,2,3,4)) -eq 1) -or ($SyntheticCallRunsSkipped -ge 3) -or $ForceNightlyTasks){
                if($appState -ne "TeamsMeeting"){
                    Write-MTRPLog "Running Network test"
                    #reset skip count
                    $AgentContext.SaveData("SyntheticCallRunsSkipped", 0)
                    if ($ForceNightlyTasks) {
                        Write-MTRPLog "ForceNightlyTasks switch detected, Performing Network Tests"
                    }
                    try { 
                        $op = Start-MTRPScriptOp -Name "T.Device.Network.SyntheticQualityTest_B" -Type "Process" 
                        Update-MTRPNetworkTestTool | Out-Null 
                        $firewallRule = Get-NetFirewallRule | Where-Object DisplayName -eq "MTRPNetworkAssessmentTool"
                        if($null -eq $firewallRule){
                            New-NetFirewallRule -DisplayName "MTRPNetworkAssessmentTool" -Direction Outbound -Program "C:\program files (x86)\microsoft teams network assessment tool\networkassessmenttool.exe" -Action Allow -Enabled True -Description "Application to perform synthetic call tests to monitor network quality"
                        }
                        $NewtorkTestResults = Start-MTRPEPNetworkTests
                    }
                    catch {Write-MTRPLog "Exception In Network Tests: $_"}
                    $NetworkQualityTest = @{
                        extensionName = "T.Device.Network.SyntheticQualityTest_B"
                        data          =  $NewtorkTestResults
                    }
                    $ScriptContext.Payload += $NetworkQualityTest
                    try { Stop-MTRPScriptOp -Name "T.Device.Network.SyntheticQualityTest_B" -Success $true }catch {}
                }
                else{
                    Write-MTRPLog "In Teams meeting skipping network test"
                }
            }
            else {
                if($null -eq $SyntheticCallRunsSkipped){$SyntheticCallRunsSkipped = 1}
                else{$SyntheticCallRunsSkipped++}
                $AgentContext.SaveData("SyntheticCallRunsSkipped", $SyntheticCallRunsSkipped)
                Write-MTRPLog "Skipping Network Tests by chance"
            }
        }
    }
    catch{
        Write-MTRPLog "Exception in T.Device.Network.SyntheticQualityTest_B: $_"
    }
    #endregion T.Device.Network.SyntheticQualityTest_B Namespace


    Write-MTRPLog "Namespace: MicrosoftStoreAppsInfo"
    #region Windows Store Apps Info
    #region Store Updates Handler

    Invoke-MTRPEPStoreHandler -FeatureFlags -MTRPDeviceID $MTRPID -featureconfig $featureconfig

    function GetAppxPackagesList
    {
        param (
        [Parameter(Mandatory)]
        [validateset("System", "Skype")]
        [string]$Account
    )
        try{
            $output = @()

            if($account -eq 'System'){
                $sid = "S-1-5-18"
            }
            elseif($account -eq 'Skype'){
                $user = New-Object System.Security.Principal.NTAccount("Skype") 
                $sid = $user.Translate([System.Security.Principal.SecurityIdentifier])
            }

            Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue | `
                Select-Object -ExpandProperty PackageUserInformation -Property Name, Version | `
                Select-Object -Property Name, Version, InstallState -ExpandProperty UserSecurityId | `
                Where-Object { $_.Sid -eq $sid} | `
                Sort-Object Name, Version, InstallState | % {
                    $output += @{
                        Name         = $_.Name
                        Version      = $_.Version
                        InstallState = $_.InstallState 
                    }
                }

            return $output
        }
        catch {
            Trace-MTRPException $_
        }
        
    }

    function GetDesktopPackageCount {
        try{
        return (Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue | Select-Object -ExpandProperty PackageUserInformation -Property Name| Where-Object { $_.Name -eq 'msteams'}).length
        }
        catch{
            Write-MTRPLog "Error in GetDesktopPackageCount: $_"
        }
        
    }
    #endregion Store Updates Handler

    #endregion
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "MicrosoftStoreAppsInfo" -Type "payload" }catch {}
    $microsoftStoreAppsInfoPayload = @{
        extensionName = "microsoftStoreAppsInfo"
        data          = @{
            XboxGamingOverlayDisabledByGpo    = Test-MTRPEPGpoSettingDisabled -GpoRegistryKey "GameDVR" -GpoSettingName "AllowgameDVR"
            XboxGamingOverlayDisabledForSkype = Test-MTRPEPWindowsSettingDisabledforUser -RegistryKey "GameDVR" -SettingName
            XboxGamingOverlayRunning          = Test-MTRPProcessRunning -ProcessName "GameBar"
            XboxGamingOverlayVersionForSkype  = Get-MTRPEPWindowsUniversalPlatformAppVersion -AppName "Microsoft.XboxGamingOverlay"
            AppxPackagesSystemAccount         = GetAppxPackagesList -Account System
            AppxPackagesSkypeAccount          = GetAppxPackagesList -Account Skype
            TeamsDesktopAppPackageCount       = GetDesktopPackageCount #Count of users with an Appx package named msteams which is the stand alone desktop client which can cause issuse when installed along side MTR app
        }
    }
    $ScriptContext.Payload += $microsoftStoreAppsInfoPayload
    try { Stop-MTRPScriptOp -Name "MicrosoftStoreAppsInfo" -Success $true }catch {}
    #endregion
    #endregion Windows Store Apps Info

    Write-MTRPLog "Namespace: hardwareInventory"
    #region hardwareInventory Namespace
    #region hardwareInventory Namespace - Combine Properties
    $modelInfo = Get-MTRPEPMTRModel -Track
    try { $op = Start-MTRPScriptOp -Name "Hardware Inventory" -Type "Process" }catch {}
    $hardwareInventoryPayload = @{
        extensionName = "hardwareInventory"
        data          = @{
            MTROEM                 = Get-MTRPEPMTROEM
            MTRUniqueModelHitCount = $modelInfo.UniqueModelHitCount
            MTRModel               = $modelInfo.Model
            PCOEM                  = Get-MTRPEPPCOEM
            PCModel                = Get-MTRPEPPCModel
            Cameras                = $mtrpPNPHardwareInfo | Where-Object { ($_.PNPClass -eq "Camera" -or $_.PNPClass -eq "Image") -and $_.ConfigManagerErrorCode -eq 0 }
            CamerasUnhealthy       = $mtrpPNPHardwareInfo | Where-Object { ($_.PNPClass -eq "Camera" -or $_.PNPClass -eq "Image") -and $_.ConfigManagerErrorCode -gt 0 }
            Audio                  = $mtrpPNPHardwareInfo | Where-Object { ($_.PNPClass -eq "Media" -and ($null -ne $_.VID)) -and $_.ConfigManagerErrorCode -eq 0}
            AudioUnhealthy         = $mtrpPNPHardwareInfo | Where-Object { ($_.PNPClass -eq "Media" -and ($null -ne $_.VID)) -and $_.ConfigManagerErrorCode -gt 0 }
        }
    }

    $ScriptContext.Payload += $hardwareInventoryPayload
    try { Stop-MTRPScriptOp -Name "Hardware Inventory" -Success $true }catch {}
    #endregion hardwareInventory Namespace - Combine Properties
    #endregion hardwareInventory Namespace

    Write-MTRPLog "Namespace: hardwareInventoryList"
    #region Hardware Inventory List Namespace - Combine Properties
    try { $op = Start-MTRPScriptOp -Name "Hardware Inventory List" -Type "Process" }catch {}
    $hardwareInventoryListPayload = @{
        extensionName = "hardwareInventoryList"
        data          = $mtrpPNPHardwareInfo | Where-Object { $_.Present -eq $true }
    }
    $ScriptContext.Payload += $hardwareInventoryListPayload
    try { Stop-MTRPScriptOp -Name "Hardware Inventory List" -Success $true }catch {}
    #endregion Hardware Inventory List Namespace - Combine Properties
    
    Write-MTRPLog "Namespace: biosSettingsList"
    #region BIOS Settings List Namespace
    #region BIOS Settings List Namespace - Functions
    #all in EP module
    #endregion BIOS Settings List Namespace - Functions
    #region BIOS Settings List Namespace - Combine Properties
    try { $op = Start-MTRPScriptOp -Name "BIOS Settings List" -Type "Process" }catch {}
    $biosSettingsListPayload = @{
        extensionName = "biosSettingsList"
        data          = Get-MTRPEPBiosSettings
    }
    $ScriptContext.Payload += $biosSettingsListPayload
    try { Stop-MTRPScriptOp -Name "BIOS Settings List" -Success $true }catch {}
    #endregion BIOS Settings List Namespace - Combine Properties
    #endregion BIOS Settings List Namespace
    
    Write-MTRPLog "Namespace: generalhardware"
    #region General Hardware Info
    #region Functions
    
    function GetDisplaylinkDriverVersion {
        $Displaylinkoutput = $null
        try { 
            $DisplaylinkDevices = Get-WmiObject Win32_PnPSignedDriver | Where-Object { $_.DeviceName -like "*DisplayLink USB Device*" } | Select-object DeviceName, DeviceID, driverversion;
            if (($DisplaylinkDevices -is [array]) -and ($DisplaylinkDevices.count -gt 0)) {
                $Displaylinkoutput = $DisplaylinkDevices[0].driverversion
            }
            else { 
                $Displaylinkoutput = $DisplaylinkDevices.driverversion 
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $Displaylinkoutput
    }
    
    function camerasDetected {
        $allCameras = @()
        try {
            $pnpCameras = Get-PnpDevice -Class Camera, Image -ErrorAction SilentlyContinue
            foreach ($camera in $pnpCameras) {
                $cameraPayload = [pscustomobject][ordered]@{
                    CameraName  = ""
                    HardwareID  = ""
                    InstanceId  = ""
                    Present     = ""
                    Status      = ""
                    ErrorCode   = ""
                    LastArrival = ""
                    LastRemoval = ""
                }
                $cameraProps = Get-PnpDeviceProperty -InstanceId $camera.InstanceID -ErrorAction SilentlyContinue
                $lastArrival = ($cameraProps | Where-Object Keyname -eq 'DEVPKEY_Device_LastArrivalDate').Data
                if ($($LastArrival.GetType()).name -eq "DateTime") {
                    $lastArrivalEpoch = [long] (Get-Date -Date $lastArrival -UFormat %s)
                } 
                $lastRemoval = ($cameraProps | Where-Object Keyname -eq 'DEVPKEY_Device_LastRemovalDate').Data
                if ($null -ne $lastRemoval) {
                    if (($LastRemoval.GetType()).name -eq "DateTime") {
                        $lastRemovalEpoch = [long] (Get-Date -Date $lastRemoval -UFormat %s)
                    }
                }
                $cameraPayload.CameraName = $camera.Friendlyname
                $cameraDeviceSelectedArray = ($camera.HardwareID -is [Array])
                $cameraSelectedHasValue = ($camera.HardwareID.count -gt 0)
                if ($cameraDeviceSelectedArray -and $cameraSelectedHasValue) {
                    $cameraPayload.HardwareID = $camera.HardwareID[0]
                }
                $cameraPayload.Present = $camera.Present
                $cameraPayload.InstanceId = $camera.InstanceId
                $cameraPayload.Status = $camera.Status
                $cameraPayload.ErrorCode = $camera.ConfigManagerErrorCode
                $cameraPayload.LastArrival = $lastArrivalEpoch
                $cameraPayload.LastRemoval = $lastRemovalEpoch
                $allCameras += $cameraPayload
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $allCameras
    }
    
    function Find-FalseDisplay {
        $out = $false
        $monitor = Get-PnpDevice -Class Monitor | Where-Object {$_.FriendlyName -like "*Non-PnP*" -or $_.FriendlyName -like "*Digital Flat Panel*"}
        if ($monitor) {
            $out = $true
        }
        return $out
    }

    function readNucHdmiFirmwareVersion {
        $NucHdmiFirmwareTrackingRegPath = 'HKLM:\Software\Microsoft\MTRP\DeviceInfo\'
        $firmwareRegValue = (GetTaskStatus $NucHdmiFirmwareTrackingRegPath 'NucHdmiFirmwareVersion').status
        if ($firmwareRegValue -eq "init") {
            return $null
        }
        Else {
            return $firmwareRegValue
        }
    }
    
    Function ethernetMACAddress {
        Try {
            (Get-NetAdapter | Where-Object name -eq "Ethernet").MacAddress | Select-Object -First 1
        }
        Catch {
            Trace-MTRPTrace $_
        }
    }
    
    function Get-IntelGraphicsInfo {
        $outputObj = @{
            Name          = $null
            DriverVersion = $null
        }
        try {
            $wmi = Get-WmiObject Win32_VideoController | Where-Object Name -like "Intel*Graphics*"
            if ($wmi -is [array]) {
                $wmi = $wmi[0]
            }
            if ($wmi) {
                $outputObj.Name = $wmi.Name
                $outputObj.DriverVersion = $wmi.DriverVersion
            }
        }
        catch { trace-mtrpexception $_ }
        return $outputObj
    }
    #endregion
    #region Combine Properties
    $NucHdmiFirmwareTrackingRegPath = 'HKLM:\Software\Microsoft\MTRP\DeviceInfo\'
    $intelGraphicsInfo = Get-IntelGraphicsInfo
    $btHardwareInfo = Get-MTRPEPBluetoothStatus
    $displayInfo = Get-MTRPEPDisplaysInfo
    $isRunning4K = $null -ne ($displayInfo | Where-Object {
            -not $_.IsMTRConsole -and
            $_.UHD4kSupported -and
            $_.Win32DesktopMonitor_ResolutionHeight -eq 2160 -and
            $_.Availability -eq "Running or Full Power" -and
            $_.Status -eq "OK"
        })
    $SystemInfo = Get-MTRPEPSystemInfo
    $DiskSpaceInfo = Get-MTRPDiskSpace
    $DiskHealthInfo = Get-MTRPEPDiskHealth
    $isThermalThrottling = if (Get-MTRPEPPerfThermalZoneTemp | Where-Object PercentPassiveLimit -lt 100) {$true} else {$false}
    # Adding in backwards compatibility parameters from the old drivesInfo function
    $DrivesInfo = Get-MTRPDiskDetails -AllDrives | Select-Object *, 
        @{ E = { $_.Drive }; N = "DriveLetter" },
        @{ E = { $_.FreeGB }; N = "FreeSpaceGB" }

    $generalhardwarePayload = @{
        extensionName = "generalhardware"
        data          = @{
            falseDisplayDetected          = Find-FalseDisplay
            intelGraphicsChip             = $intelGraphicsInfo.Name
            intelGraphicsDriverVersion    = $intelGraphicsInfo.DriverVersion
            driveserial                   = Get-MTRPDeviceID
            camerasDetected               = camerasDetected
            winConfMic                    = Get-MTRPEPWinConfiguredAudioDevice -Type ConfMic
            winConfSpk                    = Get-MTRPEPWinConfiguredAudioDevice -Type ConfSpk
            winDefMic                     = Get-MTRPEPWinConfiguredAudioDevice -Type DefMic
            winDefSpk                     = Get-MTRPEPWinConfiguredAudioDevice -Type DefSpk
            isRunning4K                   = $isRunning4K
            displaysInfo                  = $displayInfo
            # All Drive info values are rounded down to the nearest divisible by 5 value
            drivesInfo                    = $DrivesInfo
            diskSpaceFreeGB               = $DiskSpaceInfo.FreeGB
            diskSpaceFreePercent          = $DiskSpaceInfo.FreePercent
            diskSizeGB                    = $DiskSpaceInfo.SizeGB
            diskHealthFriendlyName        = $DiskHealthInfo.FriendlyName
            diskHealthDriveLetter         = $DiskHealthInfo.DriveLetter
			diskhealthDeviceId            = $DiskHealthInfo.DeviceId
            diskHealthOperationalStatus   = $DiskHealthInfo.OperationalStatus
            diskHealthStatus              = $DiskHealthInfo.HealthStatus
			diskhealthCriticalWarning     = $DiskHealthInfo.CriticalWarning
            #Current temp Rounded down to the nearest divisible by 5 value
            diskhealthTemperature         = [math]::Floor($DiskHealthInfo.Temperature / 5) * 5
            diskHealthMaxTempeature       = $DiskHealthInfo.MaxTemperatureThreshold
			diskHealthAvailableSpare      = $DiskHealthInfo.AvailableSpareBadSectors
            diskHealthSpareTheshold       = $DiskHealthInfo.AvailableSpareThreshold
			diskHealthPercetageWear       = $DiskHealthInfo.PercetageWearUsed
			diskHealthPowerOnHours        = $DiskHealthInfo.PowerOnHours
            diskHealthFWVer               = $DiskHealthInfo.FirmwareVersion
			diskHealthSerialNo            = $DiskHealthInfo.SerialNumber
            NUCType                       = Get-MTRPIntelNUCType
            SystemManufacturer            = $SystemInfo.SystemManufacturer
            SystemProductName             = $SystemInfo.SystemProductName
            SystemVersion                 = $SystemInfo.SystemVersion
            SystemSerialNumber            = $SystemInfo.SystemSerialNumber
            BoardManufacturer             = $SystemInfo.BoardManufacturer
            BoardProductName              = $SystemInfo.BoardProductName
            BoardVersion                  = $SystemInfo.BoardVersion
            BoardSerialNumber             = $SystemInfo.BoardSerialNumber
            BIOSVersion                   = $SystemInfo.BIOSVersion
            BIOSVersionSplit              = $SystemInfo.BIOSVersionSplit
            BiosReleaseDate               = $SystemInfo.BiosReleaseDate
            NucHdmiFirmwareVersion        = readNucHdmiFirmwareVersion
            NucHdmiFirmwareVersionCMDB    = (GetTaskStatus $NucHdmiFirmwareTrackingRegPath "NucHdmiFirmwareVersionCMDB").Status
            BobcatAppVersion              = (GetTaskStatus $NucHdmiFirmwareTrackingRegPath "BobcatAppVersion").Status
            IntelNUCHDMIVersion           = (GetTaskStatus $NucHdmiFirmwareTrackingRegPath "IntelNUCHDMIVersion").Status
            IntelCPUGeneration            = $(try { Get-MTRPIntelProcessorGeneration } catch { Write-MTRPLog $_.Exception.Message })
            PreviousUserDuckingPreference = (GetTaskStatus $NucHdmiFirmwareTrackingRegPath "PreviousUserDuckingPreference").Status
            BTHardwareName                = $btHardwareInfo.HardwareName
            BTHardwareStatus              = $btHardwareInfo.HardwareStatus
            BTHardwareID                  = $btHardwareInfo.HardwareID
            BTDriverVersion               = $btHardwareInfo.DriverVersion
            BTDisabled                    = $btHardwareInfo.Disabled
            BTDeviceNotFound              = $btHardwareInfo.NotFound
            BTMultipleFound               = $btHardwareInfo.MultipleDevicesFound
            BluetoothOSOn                 = $btHardwareInfo.BluetoothStatus
            DisplaylinkDriverVersion      = GetDisplaylinkDriverVersion
            FoRDisplayConnectionCounts    = Get-MTRPEPDisplayConnections
            EthernetMACAddress            = ethernetMACAddress
            ThermalThrottling             = $isThermalThrottling
        }
    }
    $ScriptContext.Payload += $generalhardwarePayload
    #endregion
    #endregion General Hardware Info
    
    Write-MTRPLog "Namespace: logitech"
    #region Logitech Info
    #region Combine Properties

    $logiSyncProxyContent = Get-MTRPEPLogiSyncProxyLogFileContent
    $syncProducts = Get-MTRPEPLogiSyncProducts -LogFileContents $logiSyncProxyContent
    $syncConnection = Get-MTRPEPLogiSyncConnectionHealth -LogFileContents $logiSyncProxyContent
    $rallyFirmwareInfo = Get-MTRPEPLogiRallyFirmwareInfoCached 
    try {
        if ($syncProducts) {
            #pull out rightSightConfiguration
            $rightSightEnabled = ($syncProducts | Where-Object rightSightConfiguration).rightSightConfiguration.enabled
            #pc location
            $pcConnectedToTableHub = (($syncProducts | Where-Object model -eq "Rally").devices | Where-Object formFactor -eq "RALLY_TABLE_HUB").isConnectedToHost
            $pcConnectedToDisplayHub = (($syncProducts | Where-Object model -eq "Rally").devices | Where-Object formFactor -eq "RALLY_TV_HUB").isConnectedToHost
            if ($pcConnectedToTableHub) {
                $pcLocation = "TableHub"
            }
            elseif ($pcConnectedToDisplayHub) {
                $pcLocation = "DisplayHub"
            }
            else {
                $pcLocation = "NA"
            }
        }
    }
    catch { Trace-MTRPException $_ }
    try { $op = Start-MTRPScriptOp -Name "logitech" -Type "payload" }catch {}
    $logitechPayload = @{
        extensionName = "logitech"
        data          = @{
            rallyConnected              = Test-MTRPEPLogiRallyConnected
            RallyPCLocation             = $pcLocation
            meetupConnected             = Test-MTRPEPLogiProductConnected Meetup
            brioConnected               = Test-MTRPEPLogiProductConnected Brio
            c930eConnected              = Test-MTRPEPLogiProductConnected c930e
            PTZPro2Connected            = Test-MTRPEPLogiProductConnected PtzPro2
            c930eFirmwareVersion        = Get-MTRPEPLogiProductFirmwareVersionCached c930e
            brioFirmwareVersion         = Get-MTRPEPLogiProductFirmwareVersionCached Brio
            meetUpFirmwareVersion       = Get-MTRPEPLogiProductFirmwareVersionCached Meetup
            PTZPro2FirmwareVersion      = Get-MTRPEPLogiProductFirmwareVersionCached PtzPro2
            LogiRallyCamFirmwareVersion = ($rallyFirmwareInfo).LogiRallyCamRegValue
            LogiRallyTableHubVersion    = ($rallyFirmwareInfo).LogiTableHubRegValue
            LogiRallyDisplayHubVersion  = ($rallyFirmwareInfo).LogiDisplayHubRegValue
            LogiRallyMicPodVersion      = ($rallyFirmwareInfo).LogiMicPodVersionRegValue
            SyncProcesses               = Test-MTRPEPLogiSyncRunning
            SyncConnectionHealth        = $syncConnection
            SyncProducts                = $syncProducts
            RightSightEnabled           = $rightSightEnabled
            SwytchPresent               = Test-MTRPEPLogiProductConnected Swytch
            RightSightHangDetected      = Get-MTRPEPLogiRightSightHangs
            TAPCat5eKitDetected         = Test-MTRPEPLogiTAPCat5eKitConnected
            SmartSoundAudioEnabled      = Test-MTRPEPLogiSmartSoundAudioEnabled
        }
    }
    $ScriptContext.Payload += $logitechPayload
    try { Stop-MTRPScriptOp -Name "logitech" -Success $true }catch {}
    #endregion
    #endregion Logitech Info
    
    Write-MTRPLog "Namespace: powerplan"
    #region Power Info
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "powerplan" -Type "payload" }catch {}
    
    $powerplanPayload = @{
        extensionName = "powerplan"
        data          = @{
            hubPowerManagementEnabled = "Deprecated"
            USBPowerSettingsCorrect   = "Deprecated"
            USBPeripheralPowerDrain   = Get-MTRPEPUSBPeripheralPowerDrain
            USBSelectiveSuspendPolicy = Get-MTRPEPSelectiveSuspendPolicy
            SleepTimerSetPWRPlan      = Get-MTRPEPSleepTimerSetPWRPlan
            CPULimitPWRPlan           = Get-MTRPEPCPULimitPWRPlan
        }
    }
    $ScriptContext.Payload += $powerplanPayload
    try { Stop-MTRPScriptOp -Name "powerplan" -Success $true }catch {}
    #endregion
    #endregion Power Info
    
    Write-MTRPLog "Namespace: os"
    #region Os Info
    #region Functions
    #Check the Device restrictions registry for pnpIDs that are blocked from taking updates
    function checkDenyDeviceIDs {
        $deviceIds = $null
        try {
            $checkDeny = Get-Item -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeviceInstall\Restrictions\DenyDeviceIDs" -ErrorAction SilentlyContinue
            if($null -ne $checkDeny)
            {
                $deviceIds = Get-MTRPItemPropertyList -Object $checkDeny -OutputObject | Select-Object -ExpandProperty *
            }    
        }
        catch {
            Trace-MTRPException $_
        }
        
        return $deviceIds;
    }
    
    # Function to check how long a room has been up. 
    # Returns the result in days, hours and minutes
    function RoomUptime {
        try {
            $RoomUptimeResult = [PSCustomObject]@{
                RoomUptimeinDays    = "NA";
                RoomUptimeinHours   = "NA";
                RoomUptimeinMinutes = "NA";
            }
    
            $uptime = (get-date -ErrorAction SilentlyContinue) - (gcim Win32_OperatingSystem).LastBootUpTime
            $RoomUptimeResult.RoomUptimeinDays = [math]::Floor($uptime.TotalDays)
            $RoomUptimeResult.RoomUptimeinHours = $uptime.TotalHours
            $RoomUptimeResult.RoomUptimeinMinutes = $uptime.TotalMinutes
                
        }
        catch {
            $RoomUptimeResult.RoomUptimeinDays = 0
    
            $RoomUptimeResult.RoomUptimeinHours = 0
            $RoomUptimeResult.RoomUptimeinMinutes = 0
            Trace-MTRPException $_ 
        }
        
        Return $RoomUptimeResult
    }
    function UBR {
        try {
            return (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").UBR;
        }
        catch { Trace-MTRPException $_ }
    }
    function CurrentBuild {
        try {
            $build = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuild
            if ($build){
                return [int]$build
            }
        }
        catch { Trace-MTRPException $_ }
    }
    function ReleaseId {
        try {
            return (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").ReleaseId;
        }
        catch { Trace-MTRPException $_ }
    }
    function ProductName {
        try {
            return (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").ProductName;
        }
        catch { Trace-MTRPException $_ }
    }
    function WindowsSKU {
        try {
            return (Get-WindowsEdition -Online).Edition;
        }
        catch { Trace-MTRPException $_ }
    }
    function HasKB {
        param (
            [Parameter()]
            [string]
            $KBId
        )
        try {
            return $null -ne (Get-HotFix -Id $KBId -ErrorAction SilentlyContinue);
        }
        catch { Trace-MTRPException $_ }
    }
    
    Function RebootFailure {
        Try {
            $RebootFail = [PSCustomObject]@{
                RebootProcess  = "NA";
                TimePoweredOn  = "NA";
                TimePoweredOff = "NA";
            }
            $sources = @("Microsoft-Windows-Kernel-General", "User32")
            $powerevents = Get-EventLog -LogName 'system' -InstanceId 13, 12, 2147484722 -Source $sources -ErrorAction SilentlyContinue
            if ($powerevents){
                For ($a = 0; $a -lt $powerevents.Count; $a++) {
                    If ($powerevents[$a].EventID -eq 12) { 
                        If ($powerevents[$a + 1].EventID -eq 13) {
                            If (($powerevents[$a].TimeGenerated - $powerevents[$a + 1].TimeGenerated).TotalMinutes -ge 30) {
                                $powerevents[$a + 2].Message -match '\w*.exe'
                                if ($null -ne $Matches) {
                                    $RebootFail.RebootProcess = if ($Matches[0]) { $Matches[0].TrimEnd() } else { "NoMatch" };
                                    $RebootFail.TimePoweredOn = $powerevents[$a].TimeGenerated;
                                    $RebootFail.TimePoweredOff = $powerevents[$a + 1].TimeGenerated;
                                    break
                                }
                            }
                        }
                    }
                }
            }
        }
        catch {
            $RebootFail.RebootProcess = "FailedToProcess";
            $RebootFail.TimePoweredOn = "FailedToProcess";
            $RebootFail.TimePoweredOff = "FailedToProcess";
            Trace-MTRPException $_ 
        }
        Return $RebootFail
    }
    function GetDsRegStatus {
        try {
            $dsregcmd = dsregcmd /status
            $outputObj = New-Object -TypeName PSObject
            $dsregcmd | Select-String -Pattern " *[A-z]+ : [A-z]+ *" | ForEach-Object {
                Add-Member -InputObject $outputObj -MemberType NoteProperty -Name (([String]$_).Trim() -split " : ")[0] -Value (([String]$_).Trim() -split " : ")[1] -Force
            }
        }
        catch {
            Trace-MTRPException $_
            $outputObj = "NotFound"
        }
        return $outputObj
    }
    
    
    function getMDMWinsOverGP {
        Try {
            $MDMWinsOverGPOutput = (get-ItemProperty -Path 'HKLM:\PolicyManager\current\device\ControlPolicyConflict' -Name 'MDMWinsOverGP' -ErrorAction SilentlyContinue).MDMWinsOverGP;
        }
        Catch {
            Trace-MTRPException $_
            $MDMWinsOverGPOutput = 'Error'
        }
        return $MDMWinsOverGPOutput
    }
    function Get-OSUpgradeHistory {
        try {
            $outputObj = @()
            $historyArray = @()
            $history = (Get-ChildItem HKLM:\System\Setup\Source* | ForEach-Object { Get-ItemProperty -Path Registry::$_ })
            $current = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion')
            $historyArray += $history
            $historyArray += $current
            $outputObj = $historyArray | Select-Object ProductName, ReleaseId, CurrentBuild, @{n = 'InstallDate'; e = { ([DateTime]'1/1/1970').AddSeconds($_.InstallDate).ToLocalTime() } } | Sort-Object 'InstallDate'
        }
        catch {
            Trace-MTRPException $_
        }
        return $outputObj
    }
    
    function isPowerShellExeMissing {
        Try {
            return !(Test-Path $env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe)
        }
        Catch { Trace-MTRPException $_ }
        return $null;
    }
    
    function IsOOBEExperiencePrompted {
        Try {
            $allWwaHostProcesses = Get-Process -IncludeUserName | Where-Object { $_.UserName -match "\\Skype$" -and $_.ProcessName -eq "wwahost" } 
            $allCloudExperienceHostProcesses = $allWwaHostProcesses | `
                Foreach-Object {
                $process = $_;
                Get-WmiObject Win32_Process | Where-Object { $_.ProcessId -eq $process.Id -and $_.CommandLine -eq "`"C:\WINDOWS\system32\wwahost.exe`" -ServerName:App.wwa"
                }
            }
    
            $allCloudExperienceHostProcesses = @($allCloudExperienceHostProcesses);
    
            return $allCloudExperienceHostProcesses.Count -gt 0;
        }
        Catch { Trace-MTRPException $_ }
        return $null;
    }
    
    
   
    function GetWinSkypeUserFormatLocale {
        Try {
            $username = 'Skype'
            $user = New-Object System.Security.Principal.NTAccount($username) 
            $sid = $user.Translate([System.Security.Principal.SecurityIdentifier]) 
            $path = "Registry::HKU\$sid\Control Panel\International"
            if ($sid -and (Test-Path $path)) {
                return (Get-ItemProperty -path $path).LocaleName;
            }
        }
        Catch { Trace-MTRPException $_ }
        return $null;
    }
    
    Function GetDailyPowerOnCount {
        try {
            (Get-EventLog -LogName 'system' -Source "Microsoft-Windows-Kernel-General" -After ((Get-Date).AddDays(-1)) | Where-Object { $_.EventId -eq 12}).count
        } catch {}
    }
    Function GetDailyRebootFromAppCount {
        try {
            (Get-EventLog -LogName System -Source User32 -After ((Get-Date).AddDays(-1)) | Where-Object { $_.EventId -eq 1074 -and $_.Message -like "*DesktopApi*Skype*"}).count
        } catch {}
    }
    Function GetDailyUnexpectedShutdownCount {
        try {
            (Get-EventLog -LogName 'system' -Source "Microsoft-Windows-Kernel-Power" -After ((Get-Date).AddDays(-1))| Where-Object { $_.EventId -eq 12}).count
        } catch {}
    }

    function TimeServiceStatus {
        try {
            $status = (Get-Service -Name "w32time").status
        }
        catch { 
            $status = "NotFound"
        }
        return $status;
    }
    Function GetCustomShellFailures {
        try {
            $ShellWinServ = (Get-EventLog -LogName 'Application' -Source "Microsoft-Windows-Winsrv" -After ((Get-Date).AddDays(-30)) -ErrorAction SilentlyContinue| Where-Object { $_.EventId -eq 10002 -and $_.Message -like "*CustomShellHost.exe*"}).count
            $ShellAppHang = (Get-EventLog -LogName 'Application' -Source "Application Hang" -After ((Get-Date).AddDays(-30))  -ErrorAction SilentlyContinue | Where-Object { $_.EventId -eq 1002 -and $_.Message -like "*CustomShellHost.exe*"}).count
            $AllHangs = (Get-EventLog -LogName 'Application' -Source "Application Hang" -After ((Get-Date).AddDays(-30))  -ErrorAction SilentlyContinue | Where-Object { $_.EventId -eq 1002}).count
            $AppPopup = (Get-EventLog -LogName 'System' -After ((Get-Date).AddDays(-1))  -ErrorAction SilentlyContinue | Where-Object { $_.EventId -eq 26}).count
            Return @{
                ShellWinServ = $ShellWinServ
                ShellAppHang = $ShellAppHang
                AllHangs = $AllHangs
                AppPopUp = $AppPopup
            }
        } catch {}
    }
    $NightlyRebootState = Get-MTRPEPScheduleTaskNightlyReboot 
    #endregion
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "os" -Type "payload" }catch {}
    $RebootFailure = RebootFailure
    $RoomUptimeResult = RoomUptime
    $ActivationStatus = Get-MTRPEPOSActivationStatus
    $OsPayload = @{
        extensionName = "os"
        data          = @{
            Win11Info                      = Get-MTRPWin11Info
            OSUpgradeHistory               = Get-OSUpgradeHistory
            OSVersionStaged                = (GetTaskStatus 'HKLM:\Software\Microsoft\MTRP\Updates\UpdateOSFeatureVersion' 'OSVersionStaged').status
            DeviceDriverDenyList           = checkDenyDeviceIDs
            #Uptime rounded down to nearest value, daily rebooting devices should always show 0
            RoomUptimeinDays               = $RoomUptimeResult.RoomUptimeinDays
            SKDTaskNightlyRebootState      = $NightlyRebootState.State
            SKDTaskNightlyRebootLastRun    = $NightlyRebootState.LastRunTime
            SKDTaskNightlyRebootLastResult = $NightlyRebootState.LastTaskResult
            SKDTaskNightlyRebootNotFound   = $NightlyRebootState.NoTaskFound
            OSDaysSinceFirstBoot           = Get-MTRPEPOSDaysSinceFirstBoot
            ubr                            = UBR
            currentBuild                   = CurrentBuild
            releaseId                      = ReleaseId
            productName                    = ProductName
            windowsEdition                 = WindowsSKU
            ActivationStatus               = $ActivationStatus.ActivationStatus
            LicenseStatusReason            =$ActivationStatus.LicenseStatusReason
            OSLicenseUEFI                  = $ActivationStatus.LicenseUEFI
            DailyRebootFromAppCount        = GetDailyRebootFromAppCount
            DailyPowerOnCount              = GetDailyPowerOnCount
            DailyUnexpectedShutdownCount   = GetDailyUnexpectedShutdownCount
            KB4550945                      = HasKB("KB4550945")
            #KB4567514                   = HasKB("KB4567514") KB for 1803 upgrade failure
            KB4562251                      = HasKB("KB4562251")
            KB4571709                      = HasKB("KB4571709")
            KB4565351                      = HasKB("KB4565351")
            KB4592449                      = HasKB("KB4592449")
            KB5004945                      = HasKB("KB5004945") #Print Spooler patch for 2004 and above
            KB5004946                      = HasKB("KB5004946") #Print Spooler patch for 1909
            KB5003974                      = HasKB("KB5003974") #Servicing Stack pack for 1909
            KB5003173                      = HasKB("KB5003173") #Servicing Stack pack for 2004 and above
            KB4598481                      = HasKB("KB4598481") #Servicing Stack pack for 2004
            KB5005031                      = HasKB("KB5005031") # 1909 - August 10, 2021 Cummulative Update
            KB5005412                      = HasKB("KB5005412") # Aug 2021 - Servicing Stack pack for 1909
            rebootFailureProcess           = $RebootFailure.RebootProcess
            rebootFailureTimePoweredOff    = $RebootFailure.TimePoweredOff
            rebootFailureTimePoweredOn     = $RebootFailure.TimePoweredOn
            networkConnectionType          = Get-MTRPEPNetworkConnectionType
            dismScan                       = (GetTaskStatus "HKLM:\Software\Microsoft\MTRP\Maintenance\" 'DiskScan').status
            dsregcmdStatus                 = GetDsRegStatus
            checkQoSPolicy                 = Get-MTRPQosPolicy
            getMDMWinsOverGP               = getMDMWinsOverGP
            PowerShellExeMissing           = isPowerShellExeMissing
            ExecutionPolicySession         = Get-ExecutionPolicy
            ExecutionPolicyCurrentUser     = Get-ExecutionPolicy -Scope CurrentUser
            ExecutionPolicyLocalMachine    = Get-ExecutionPolicy -Scope LocalMachine
            ExecutionPolicyMachinePolicy   = Get-ExecutionPolicy -Scope MachinePolicy
            ExecutionPolicyUserPolicy      = Get-ExecutionPolicy -Scope UserPolicy
            ExecutionPolicyProcess         = Get-ExecutionPolicy -Scope Process
            UACConsentPromptBehaviorUser   = GetRegValue -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "ConsentPromptBehaviorUser"
            UACPromptOnSecureDesktop       = GetRegValue -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "PromptOnSecureDesktop"
            IsOOBEExperiencePrompted       = IsOOBEExperiencePrompted
            UnattendedAutoLogon            = GetRegValue -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Setup\OOBE" -Name "UnattendSetAutologon"
            WinSystemLocale                = $(try { (Get-WinSystemLocale).Name } catch { Trace-MTRPException $_ })
            WinSkypeUserFormatLocale       = GetWinSkypeUserFormatLocale
            timeSkew                       = Get-MTRPEPTimeSkew 
            timeServiceStatus              = TimeServiceStatus
            DynamicDaylightSavingsDisabled = GetRegValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\TimeZoneInformation" -Name "DynamicDaylightTimeDisabled"
            osRollbackRequired             = $(Test-MTRPUpdateCompatibility -Name Registry -Value 19044 -CompareOp gt -ItemName "CurrentBuild" -RegistryPath "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion")
            HangEvents                     = GetCustomShellFailures
            ConfiguredNTPServers           = Get-MTRPNtpServer
            WebView2Version                = GetRegValue -Path 'HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\Clients\{F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}' -Name pv
        }
    }
    $ScriptContext.Payload += $OsPayload
    try { Stop-MTRPScriptOp -Name "os" -Success $true }catch {}
    #endregion
    #endregion Os Info
    
    Write-MTRPLog "Namespace: installedSoftwareList"
    #region Installed Software List namespace
    #region Functions - Installed Software List namespace
    function Get-InstalledSoftwareList {
        Try {
            $getsoftwares = @()
            $getsoftwares += Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object @{Name = "InstallDate"; Expression = { ([datetime]::ParseExact($_.InstallDate, 'yyyyMMdd', $null)).toshortdatestring() } } , DisplayName, DisplayVersion | Where-Object DisplayName -ne $null
            $getsoftwares += Get-ItemProperty HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object @{Name = "InstallDate"; Expression = { ([datetime]::ParseExact($_.InstallDate, 'yyyyMMdd', $null)).toshortdatestring() } } , DisplayName, DisplayVersion | Where-Object DisplayName -ne $null 
            $getsoftwares =  $getsoftwares | Sort-Object InstallDate -Descending
            return $getsoftwares
        }
        Catch { Trace-MTRPException $_ }
    }
    #endregion Functions - Installed Software List namespace
    #region Combine Properties - Installed Software List namespace
    try { $op = Start-MTRPScriptOp -Name "Installed Software List" -Type "payload" }catch {}
    $installedSoftwareList = @{
        extensionName = "installedSoftwareList"
        data          = Get-InstalledSoftwareList
    }
    $ScriptContext.Payload += $installedSoftwareList
    try { Stop-MTRPScriptOp -Name "Installed Software List" -Success $true }catch {}
    #endregion Combine Properties - Installed Software List namespace
    #endregion Installed Software List namespace
    
    Write-MTRPLog "Namespace: softwareInventory"
    #region Software Inventory
    #region Functions - Software Inventory namespace
    
    function Get-SoftwareInventory {
        try {
            # Registry keys containing uninstall strings for installed software
            $Path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall", 
            "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    
            # Get the list of software where there's actual item properties
            $Software = Get-ChildItem -Path $Path | Get-ItemProperty | 
            Sort-Object PSChildName | Select-Object PSChildName, DisplayVersion
    
            # Return data with inventory hash table
            $Return = [ordered]@{}
    
            <# 
            DisplayName does not always return a unique value so we use the regkey "uninstall guid" as the name.
            In some cases, like KB installs, there's no data contained in the key but the key name is unique to the installation.
            
            Name                           Value
            ----                           -----
            {010792BA-551A-3AC0-A7EF-0FAB... 12.0.40664
            {017C228A-33BE-45BC-9651-DF83... 1.2.2130.0
            {042d26ef-3dbe-4c25-95d3-4c1b... 12.0.40664.0
            #>
            
            $Software | ForEach-Object { $Return[$_.PSChildName] = $_.DisplayVersion }
    
            return $Return
        }
        catch { Trace-MTRPException $_ }
    }
    

    function Get-IntelDSA {
        param (
            [switch]$Detailed,
            [switch]$VersionOnly
        )

        try {
            $Return = @{ Details = @{} }
            $Path = "C:\ProgramData\Package Cache\*\Intel-Driver-and-Support-Assistant-Installer.exe"
            $Return.Exists = Test-Path $Path
            if ($Return.Exists) {
                $Item = Get-ChildItem $Path
                if ($Item) {
                    $Guid = ($Item.FullName).Split("\")[-2]
                    if ($Guid) {
                        $Details = Get-Package | Where-Object { $_.FastPackageReference -match $Guid } | Select-Object Name, Version
                        $Details | ForEach-Object {
                            $Return.Details[$_.Name] = $_.Version
                        }
                        $Return.Version = $Return.Details.Values | Sort-Object | Select-Object -First 1
                        if (-not $Return.Version) { $Return.Version = "NA" }
                    }
                }
            }

            if ($Detailed) {
                return $Return
            }
            elseif ($VersionOnly) {
                return $Return.Version
            }
            else {
                return $Return.Exists
            }
        }
        catch {
            Write-MTRPLog -Exception $_
        }
    }
    #endregion Functions - Software Inventory namespace
    
    #region Combine Properties - Software Inventory namespace
    $IntelDSA = Get-IntelDSA -Detailed
    try { $op = Start-MTRPScriptOp -Name "Software Inventory" -Type "payload" } catch {}
    
    $softwareInventory = @{
        extensionName = "softwareInventory"
        data          = @{
            inventory = Get-SoftwareInventory
            specificPackages = @{
                HasIntelDSA = $IntelDSA.Exists
                IntelDSAVersion = $IntelDSA.Version
            }
        }
    }
    
    if ($IntelDSA.Details.Count) {
        $IntelDSA.Details.GetEnumerator() | 
            ForEach-Object {
                $softwareInventory.data.specificPackages[$_.Name] = $_.Value
            }
    }
    $ScriptContext.Payload += $softwareInventory
    
    try { Stop-MTRPScriptOp -Name "Software Inventory" -Success $true } catch {}
    
    #endregion Combine Properties - Software Inventory namespace
    
    #endregion Software Inventory

    Write-MTRPLog "Namespace: wuInfo"
    #region WU Info
    #region Functions
    function wuFeatureDefermentDays {
        param (
            [Parameter()]
            [ValidateSet("GPO", "MDM", "OSSettings")]
            [string]$PolicyType
        )
        switch ($PolicyType) {
            "GPO" {
                $FeatureDefermentDays = (Get-ItemProperty "HKLM:\Software\Policies\Microsoft\Windows\WindowsUpdate" -Name DeferFeatureUpdatesPeriodInDays -ErrorAction SilentlyContinue).DeferFeatureUpdatesPeriodInDays
            }
            "MDM" {
                $FeatureDefermentDays = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\PolicyManager\current\device\Update" -name DeferFeatureUpdatesPeriodInDays -ErrorAction SilentlyContinue).DeferFeatureUpdatesPeriodInDays
            }
            "OSSettings" {
                $FeatureDefermentDays = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings' -name DeferFeatureUpdatesPeriodInDays -ErrorAction SilentlyContinue).DeferFeatureUpdatesPeriodInDays
            }
        }
        return $FeatureDefermentDays
    }
    function MicrosoftStoreUpdate {
        return (Get-ItemProperty 'HKLM:\Software\Policies\Microsoft\WindowsStore' -ErrorAction SilentlyContinue).AutoDownload
    }
    function WSUSServerURL {
        param (
            [Parameter()]
            [ValidateSet("GPO", "MDM")]
            [string]$PolicyType
        )
        switch ($PolicyType) {
            "GPO" {
                $WUServerURL = (Get-ItemProperty "HKLM:\Software\Policies\Microsoft\Windows\WindowsUpdate" -Name WUServer -ErrorAction SilentlyContinue).WUServer
            }
            "MDM" {
                $WUServerURl = (Get-ItemProperty "HKLM:\Software\Microsoft\PolicyManager\default\Update\UpdateServiceURL" -name value -ErrorAction SilentlyContinue).value
            }
        }
        return $WUServerURL
    }
    
    function useWUServer {
        $useWUServer = (Get-ItemProperty "HKLM:\Software\Policies\Microsoft\Windows\WindowsUpdate\AU" -Name UseWUServer -ErrorAction SilentlyContinue).UseWUServer
        return $useWUServer
    
    }
    function checkWUService {
        try {
            $service = Get-Service wuauserv
        }
        catch { Trace-MTRPException $_ }
        return $service.Status
    }
    
    function getSetupDiagOutput {
        $outputObj = [PSCustomObject] [ordered]@{
            ProfileName      = "NotFound"
            FailureData      = "NotFound"
            FailureDetails   = "NotFound"
            TargetOS         = "NotFound"
            RegisteredAV     = "NotFound"
            UpgradeStartTime = "NotFound"
        }
        try {
            $json = Get-Content C:\rigel\Temp\Logging\setupdiag.json -ErrorAction SilentlyContinue
            if ($json) {
                $jsonResults = $json | ConvertFrom-Json
                $outputObj.ProfileName = $jsonResults.ProfileName
                $outputObj.FailureData = $jsonResults.FailureData[0]
                $outputObj.FailureDetails = $jsonResults.FailureDetails
                $outputObj.TargetOS = $jsonResults.SystemInfo.TargetOSBuildString
                $outputObj.RegisteredAV = $jsonResults.SystemInfo.RegisteredAV
                $outputObj.UpgradeStartTime = $jsonResults.SystemInfo.UpgradeStartTime
            }
            else {
                Trace-MTRPTrace "SetupDiag JSON output file not found"
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $outputObj
    }
    function GetMtrAppTargetReleaseVersionSet {
        try {
            $UpdateCSP = get-ciminstance -namespace 'root\cimv2\mdm\dmmap' -classname 'MDM_Policy_Config01_Update02';
            return $UpdateCSP.TargetReleaseVersion;
        }
        catch { Trace-MTRPException $_ }
        return $null;
    }
    try {
        $mtrpOSFeatureBlockTask = Get-ScheduledTask -TaskName "MTRPOSTargetReleaseVersion_1" -ErrorAction SilentlyContinue
        $mtrpOSFeatureBlockTaskInfo = Get-ScheduledTaskInfo -TaskName "MTRPOSTargetReleaseVersion_1" -ErrorAction SilentlyContinue
    } catch {}
    #endregion
    try { $setupDiagResults = getSetupDiagOutput } catch {}
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "wuInfo" -Type "payload" }catch {}
    $wuInfoPayload = @{
        extensionName = "wuInfo"
        data          = @{
            microsoftstoreupdates              = MicrosoftStoreUpdate
            wuService                          = checkWUService
            wuFeatureDefermentDaysGPO          = wuFeatureDefermentDays GPO
            wuFeatureDefermentEnabledGPO       = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name DeferFeatureUpdates
            wuFeatureDefermentDaysMDM          = wuFeatureDefermentDays MDM
            wuFeatureDefermentDaysOSSettings   = wuFeatureDefermentDays OSSettings
            useWUServer                        = useWUServer
            wsusServerURLGPO                   = WSUSServerURL GPO
            wsusServerURLMDM                   = WSUSServerURL MDM
            setupDiagProfile                   = $setupDiagResults.ProfileName
            setupDiagFailureData               = $setupDiagResults.FailureData
            setupDiagFailureDetails            = $setupDiagResults.FailureDetails
            setupDiagTargetOS                  = $setupDiagResults.TargetOS
            setupDiagRegisteredAV              = $setupDiagResults.RegisteredAV
            setupDiagUpgradeStartTime          = $setupDiagResults.UpgradeStartTime
            oSSettingsBranchReadinessLevel     = GetRegValue "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings" -Name "BranchReadinessLevel"
            gpoBranchReadinessLevel            = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name "BranchReadinessLevel"
            gpoTargetReleaseVersion            = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name TargetReleaseVersionInfo
            gpoTargetReleaseVersionEnabled     = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name TargetReleaseVersion
            mdmTargetReleaseVersion            = GetRegValue "HKLM:\SOFTWARE\Microsoft\PolicyManager\current\device\Update" -Name TargetReleaseVersion
            gpoDeferQualityUpdatesEnabled      = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name DeferQualityUpdates
            gpoDeferQualityUpdatesPeriodInDays = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name DeferQualityUpdatesPeriodInDays
            mdmDeferQualityUpdatesPeriodInDays = GetRegValue "HKLM:\SOFTWARE\Microsoft\PolicyManager\current\device\Update" -Name DeferQualityUpdatesPeriodInDays
            gpoDoNotConnectInternetLocations   = GetRegValue "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -Name DoNotConnectToWindowsUpdateInternetLocations
            gpoUninstallWindow                 = GetRegValue "HKLM:\SYSTEM\Setup" -Name UninstallWindow
            mdmMtrAppTargetReleaseVersion      = GetMtrAppTargetReleaseVersionSet
            wuBlocked                          = $(try { -not (Test-MTRPTcpConnectivity -PassFail -WindowsUpdate) } catch { Trace-MTRPException $_ })
            wuStatus                           = Test-MTRPWindowsUpdate -Flatten
            mTRPOSTargetReleaseTaskState       = $mtrpOSFeatureBlockTask.State
            mTRPOSTargetReleaseTaskLastRunTime = $mtrpOSFeatureBlockTaskInfo.LastRunTime

        }
    }
    
    $ScriptContext.Payload += $wuInfoPayload
    try { Stop-MTRPScriptOp -Name "wuInfo" -Success $true }catch {}
    #endregion
    #endregion WU Info

    Write-MTRPLog "Namespace: wuTargetInfo"

    #region OS Version Handler

    Invoke-MTRPEPOsVersionHandler -FeatureFlags -MTRPDeviceID $MTRPID -featureconfig $featureconfig
    
    #endregion OS Version Handler


    #region WU Target Info
    
    $wuHandler = Invoke-MTRPEPWUHandler -FeatureFlags -MTRPDeviceID $MTRPID -featureconfig $featureconfig
    
    try { $op = Start-MTRPScriptOp -Name "wuTargetInfo" -Type "payload" }catch {}

    $wuTargetInfoPayload = @{
        extensionName = "wuTargetInfo"
        data          = @{}
    }

    $wuHandler | ForEach-Object { $_.PSObject.Properties | ForEach-Object { $wuTargetInfoPayload.data[$_.Name] = $_.Value } }
    $ScriptContext.Payload += $wuTargetInfoPayload
    try { Stop-MTRPScriptOp -Name "wuTargetInfo" -Success $true }catch {}
    #endregion  WU Target Info

    
    Write-MTRPLog "Namespace: app"
    #region App info
    #region Functions
    
    function GetAppLastConfiguredAudioDevice {
        param(
            [Parameter(Mandatory)]
            [String[]]
            [ValidateSet("Mic", "ConfSpk", "DefSpk")]
            $Type
        )

        $outputObj = [PSCustomObject][ordered]@{
            DeviceName         = "FailedToProcess"
            Present            = ""
            ErrorCode          = ""
            HardwareID         = ""
            LastArrival        = ""
            LastRemoval        = ""
            ParentHardwareID   = ""
            ParentFriendlyName = ""
        }

        try {
            $path = 'C:\Users\Skype\AppData\Local\Packages\Microsoft.SkypeRoomSystem_8wekyb3d8bbwe\LocalState\Tracing\*'
            if (Test-Path $path) {
                $files = Get-ChildItem $path -Include SkypeRoom-Init* | Select-Object -Last 6 | Sort-Object -Descending
            }

            if ($files) {
                $content = $null
                foreach ($file in $files) {
                    $content += Get-Content $file.fullname
                }
                switch ($Type) {
                    "Mic" {
                        $logLines = @($content) -like "*AudioCaptureCommunicationsDevice =*"
                    }
                    "ConfSpk" {
                        $logLines = @($content) -like "*AudioRenderCommunicationsDevice =*"
                    }
                    "DefSpk" {
                        $logLines = @($content) -like "*AudioRenderDefaultDevice =*"
                    }
                }
                if ($logLines) {
                    $lastLine = $logLines | Select-Object -Last 1
                    $deviceNameInLog = $lastLine.Split("=")[1].TrimStart()
                    If (![string]::IsNullOrWhiteSpace($deviceNameInLog)) {
                        $pnpDevice = Get-PnpDevice -FriendlyName $deviceNameInLog -ErrorAction SilentlyContinue
                    }
                    If ($null -ne $pnpDevice) {
                        if ($pnpDevice.count -gt 1) {
                            $pnpDevice = $pnpDevice[0]
                            $pnpProps = Get-PnpDeviceProperty -InstanceId $pnpDevice[0].InstanceID
                        }
                        else {
                            $pnpProps = Get-PnpDeviceProperty -InstanceId $pnpDevice.InstanceID
                        }
            
                        $lastArrival = ($pnpProps | Where-Object Keyname -eq 'DEVPKEY_Device_LastArrivalDate').Data
                        if ($null -ne $lastArrival) {
                            Try {
                                if (($LastArrival.GetType()).name -eq "DateTime") {
                                    $lastArrivalEpoch = [long] (Get-Date -Date $lastArrival -UFormat %s)
                                }
                                else {
                                    $lastArrivalEpoch = ""
                                }
                            } 
                            Catch {
                                Trace-MTRPException $_
                                $lastArrivalEpoch = ""
                            }
                        }
                        else {
                            $lastArrivalEpoch = ""
                        }
                        $lastRemoval = ($pnpProps | Where-Object Keyname -eq 'DEVPKEY_Device_LastRemovalDate').Data
                        if ($null -ne $lastRemoval) {
                            try {
                                if (($LastRemoval.GetType()).name -eq "DateTime") {
                                    $lastRemovalEpoch = [long] (Get-Date -Date $lastRemoval -UFormat %s)
                                } 
                                Else {
                                    $lastRemovalEpoch = ""
                                }
                            }
                            catch {
                                Trace-MTRPException $_
                                $lastRemovalEpoch = ""
                            }
                        }
                        Else {
                            $lastRemovalEpoch = ""
                        }
                        $parentInstanceID = ($pnpProps | Where-Object Keyname -eq 'DEVPKEY_Device_Parent').Data
                        $parentPNPDevice = $(try { Get-PnpDevice -InstanceId $parentInstanceID } catch { Trace-MTRPException $_ })
                        $outputObj.DeviceName = $pnpDevice.Friendlyname
                        $pnpDeviceSelectedArray = ($pnpDevice.HardwareID -is [Array])
                        $pnpDeviceSelectedHasValue = ($pnpDevice.HardwareID.count -gt 0)
                        if ($pnpDeviceSelectedArray -and $pnpDeviceSelectedHasValue) {
                            $outputObj.HardwareID = $pnpDevice.HardwareID[0]
                        }
                        $outputObj.Present = $pnpDevice.Present
                        $outputObj.ErrorCode = $pnpDevice.ConfigManagerErrorCode
                        $outputObj.LastArrival = $lastArrivalEpoch
                        $outputObj.LastRemoval = $lastRemovalEpoch
                        $parentPNPDeviceArray = ($parentPNPDevice.HardwareID -is [Array])
                        $parentPNPDeviceHasValue = ($parentPNPDevice.HardwareID.count -gt 0)
                        if ($parentPNPDeviceArray -and $parentPNPDeviceHasValue) {
                            $outputObj.ParentHardwareID = $parentPNPDevice.HardwareID[0]
                        }
                        $outputObj.ParentFriendlyName = $parentPNPDevice.FriendlyName
                    }
                }
                else {
                    Write-MTRPLog "No Device $($Type) Found in Log Files" -Warning
                }    
            }
            else {
                Write-MTRPLog "No Log Files Found"
            }
        }
        catch {
            Write-MTRPLog -Exception $_
        }

        return $outputObj
    }

    function IsDASRunning {
        try {
            return $null -ne (Get-Process DesktopAPIService -ErrorAction SilentlyContinue);
        }
        catch { Trace-MTRPException $_ }
    }
    function SignedInUser {
        try {
            $signedinUsername = Get-WMIObject -class Win32_ComputerSystem -Property username
            If ($null -ne $signedinUsername.username) {
                $signedinUsername = $signedinUsername.username.split('\')[1];
                return $signedinUsername;
            }
            Else {
                return "Not Found"
            }
            
        }
        catch { Trace-MTRPException $_ }
    }
    function IsWatchdogRunning {
        try {
            return $null -ne (Get-Process Watchdog -ErrorAction SilentlyContinue);
        }
        catch { Trace-MTRPException $_ }
    }
    function IsAutoLoginEnabled {
        try {
            return (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon').AutoAdminLogon;
        }
        catch { Trace-MTRPException $_ }
    }
    Function IsLogErrorFlooded {
        Try {
            $a = Get-EventLog -LogName 'Skype Room System' -Newest 10
            $errorCount = 0
            
            Foreach ($event in $a) {
                If ($event.InstanceID -eq '5000') {
                    $errorCount++
                }
            }
            If ($errorCount -gt 7) {
                Return $true
            }
            Else {
                Return $false
            }
        }
        Catch {
            Trace-MTRPException $_ 
            Return $null
        }
    
    }
    Function HasCustomShellSet {
        Try {
            return $null -ne (Get-CimInstance -Namespace "root\cimv2\mdm\dmmap" -ClassName "MDM_AssignedAccess" -ErrorAction Stop).ShellLauncher
        }
        Catch {
            Trace-MTRPException $_ 
            Return $null
        }
    }
    Function BootIDTimeOut {
        Try {
            $bootTime = (Get-CimInstance -ClassName win32_operatingsystem).lastbootuptime 
            $events = Get-EventLog -LogName "Skype Room System" -InstanceId 1102 -After $bootTime -ErrorAction SilentlyContinue
                
            foreach ($event in $events) {
                if ($event.Message -match "Timed out waiting for the boot Id to be set") { return $true }
            }
    
            return $false
        }
        Catch {
            Trace-MTRPException $_ 
            Return $null
        }
    }
   
    function getSkypeHighContrastFlags {
        $skypeUserRegPath = Get-MTRPSkypeUserRegPath
        return GetRegValue -Path "$($skypeUserRegPath)\Control Panel\Accessibility\HighContrast" -Name "Flags"    
    }

    function getUserHighContrastEnabled([string]$Username) {
        $UsrSid = (New-Object System.Security.Principal.NTAccount($Username)).Translate([System.Security.Principal.SecurityIdentifier]).Value
        GetRegValue -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\SystemProtectedUserData\$UsrSid\AnyoneRead\Colors" -Name "HighContrastEnabled"
    }

    function getTACInfo {
        try{
            $appprop =  get-item C:\ProgramData\Microsoft\Windows\WinAgent\Prod\app_properties.json -ErrorAction SilentlyContinue
            $winagent =  get-item C:\ProgramData\Microsoft\Windows\WinAgent\Prod\win_agent.json -ErrorAction SilentlyContinue

            if($appprop){
                $apppropJson = Get-Content C:\ProgramData\Microsoft\Windows\WinAgent\Prod\app_properties.json
                $appPropObject = $apppropJson | ConvertFrom-Json
            }

            if($winagent){
                $winagentJson = Get-Content C:\ProgramData\Microsoft\Windows\WinAgent\Prod\win_agent.json
                $winagentObject = $winagentjson | ConvertFrom-Json 
            }

            $TacProcess = get-process WinAgentSvc -ErrorAction SilentlyContinue
            if($TacProcess){
            $TacAgentRunning = $true
            $TacAgentVersion = $TacProcess.ProductVersion
            }
            else{
                $TacAgentRunning = $false
                $TacAgentVersion = $null
            }
        }
        catch{
            Write-MTRPLog -Exception $_
        }


        $TACInfo =  [PSCustomObject]@{
            winAgentLastWrite    = $winagent.LastWriteTime
            TacAgentRunning      = $TacAgentRunning
            TACProcessVersion    = $TacAgentVersion
            DmDeviceId           = $winagentObject.DeviceId
            TACUserId            = $appPropObject.loggedinUserId
            TACTenantId          = $appPropObject.serviceDescription.tenantId
        }
        return $TACInfo
    }
    function getWatchDogError0x80040900 {
        try{
            $result = $null
            $watchDogPath = "C:\Users\Skype\AppData\Local\Packages\Microsoft.SkypeRoomSystem_8wekyb3d8bbwe\LocalState\Tracing\watchdog.txt"
            if(Test-Path $watchDogPath){
                $ErrorCount = 0
                $WatchdogData = get-content $watchDogPath
                foreach($line in $WatchdogData){
                    if($line -like "*0x80040900*"){
                        $ErrorTime = Find-MTRPDatetime $line
                        $ErrorTimeSecs = ([DateTimeOffset]$ErrorTime).ToUnixTimeSeconds()
                        if($ErrorCount -eq 0){
                            $firstErrorTime = $ErrorTimeSecs
                        }
                        $errorCount++
                    }
                }
                $result = @{
                    firstErrorTime = $firstErrorTime
                    lastErrorTime = $ErrorTimeSecs
                    errorCount = $errorCount
                }
            }
            return $result
        }
        catch{
            Write-MTRPLog "Exception in watchDogError0x80040900: $_"
            return $null
        }
    }

    #endregion
    #region Combine Properties
    $appSIPAddressDomain = Get-MTRPEPAppSIPAddressDomain
    $appxPackageDetails = Get-MTRPEPMtrAppxPackageDetails
    try { $op = Start-MTRPScriptOp -Name "app" -Type "payload" }catch {}
    $AppPayload = @{
        extensionName = "app"
        data          = @{
            isDasRunning                = IsDASRunning
            isWatchdogRunning           = IsWatchdogRunning
            signedInUser                = SignedInUser
            isAutoLoginEnabled          = IsAutoLoginEnabled
            appUserName                 = Get-MTRPEPAppUserName
            appUserNameDomain           = Get-MTRPEPAppUserDomain
            appSIPAddress               = Get-MTRPEPAppSIPAddress
            appSIPAddressDomain         = $appSIPAddressDomain
            appLastUsedCamera           = Get-MTRPEPAppLastUsedCamera
            appLastConfiguredDefMic     = GetAppLastConfiguredAudioDevice -Type Mic
            appLastConfiguredDefConfSpk = GetAppLastConfiguredAudioDevice -Type ConfSpk
            appLastConfiguredDefSpk     = GetAppLastConfiguredAudioDevice -Type DefSpk
            #isStrictTLSonSubdomains     = Test-MTRPEPStrictTlsOnSubdomains -TestDomain $appSIPAddressDomain
            UserOID                     = Get-MTRPEPAppUserOID
            isLogErrorFlooded           = IsLogErrorFlooded
            hasCustomShellSet           = HasCustomShellSet
            bootIDTimeOut               = BootIDTimeOut
            skypehighContrastFlags      = getSkypeHighContrastFlags
            skypehighContrastEnabled    = getUserHighContrastEnabled -Username "Skype"
            TACInfo                     = getTACInfo
            watchDogError0x80040900     = getWatchDogError0x80040900
            TeamsMeetingPolicyInfo      = Get-MTRPTeamsMeetingPolicyInfo
        }
    }

    # Append all package details to the payload
    if($null -ne $appxPackageDetails) {    
        $appxPackageDetails.PSObject.Properties | ForEach-Object { $AppPayload.data[$_.Name] = $_.Value } 
    }
    $ScriptContext.Payload += $AppPayload
    try { Stop-MTRPScriptOp -Name "app" -Success $true }catch {}
    #endregion
    #endregion App info
 
    Write-MTRPLog "Namespace: atp"
    #region ATP Info
    #region Functions
    function IsAtpInstalled {
        try {
            return (Get-Item 'HKLM:\SOFTWARE\Microsoft\Windows Advanced Threat Protection\Status' -ErrorAction SilentlyContinue) -and 1 -eq (Get-Item 'HKLM:\SOFTWARE\Microsoft\Windows Advanced Threat Protection\Status' -ErrorAction SilentlyContinue).GetValue('OnboardingState', $null)
        }
        catch { Trace-MTRPException $_ }
    }
    #endregion
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "atp" -Type "payload" }catch {}
    $atpPayload = @{
        extensionName = "atp"
        data          = @{
            isAtpInstalled = IsAtpInstalled
        }
    }
    $ScriptContext.Payload += $atpPayload
    try { Stop-MTRPScriptOp -Name "atp" -Success $true }catch {}
    #endregion
    #endregion ATP Info

    Write-MTRPLog "Namespace: polycom"
    #region PolyStudio Info
    #region Functions
    # This function returns the firmware version of a Polycom studio
    function PolyStudioFirmwareVersion {
        try {
            #return PolyStudio firmware version represented with 4 digit. Full string example {USB\VID_095D&PID_9217&REV_0735&MI_00, USB\VID_095D&PID_9217&MI_00}.
            #We split the full string to get just the 4 digit version e.g 0735
            $pnpDevice = Get-PnpDevice -PresentOnly | Where-Object {
                $_.FriendlyName -match "(Poly |Polycom )Studio (DFU |[A-Z0-9]{3,} DFU )Runtime"
            }

            if ($pnpDevice) {
                $rev = ($pnpDevice.HardwareID | where-object { $_ -match 'REV' }).split('&')[2].split('_')[1]
            }
            else {
                $rev = $null  #"NotFound"
            }
            return $rev;
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function PolycomConnected {
        try {
            return $null -ne (Get-PnpDevice -PresentOnly | Where-Object { $_.FriendlyName -match "(Poly |Polycom )" })
        }
        catch { Trace-MTRPException $_ }
    }
    function PolyStudioConnected {
        try {
            $pnpDevice = Get-PnpDevice -PresentOnly | Where-Object {
                $_.FriendlyName -match "(Poly |Polycom )Studio (DFU |[A-Z0-9]{3,} DFU )Runtime"
            }

            return $null -ne $pnpDevice
        }
        catch { Trace-MTRPException $_ }
    
    }
    function PolyStudioinDFUMode {
        try {
            $pnpDevice = Get-PnpDevice -PresentOnly | Where-Object { $_.InstanceId -like "*VID_095D&PID_9218*" }
            return $null -ne $pnpDevice
        }
        catch { Trace-MTRPException $_ }
    }
    #endregion
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "polycom" -Type "payload" }catch {}
    $PolycomPayload = @{
        extensionName = "polycom"
        data          = @{
            polycomConnected          = PolycomConnected
            polyStudioConnected       = PolyStudioConnected
            polyStudioFirmwareVersion = PolyStudioFirmwareVersion
            polyStudioinDFUMode       = PolyStudioinDFUMode
        }
    }
    $ScriptContext.Payload += $PolycomPayload
    try { Stop-MTRPScriptOp -Name "polycom" -Success $true }catch {}
    #endregion
    #endregion PolyStudio Info

    Write-MTRPLog "Namespace: hp"
    #region HP Slice Info
    #region Functions
    # This function returns the HP HDMI firmware version of a HP Slice
    function HPSliceIngestFirmwareVersion {
        try {
            #return HP firmware version represented with 4 digit. Full string example {USB\VID_095D&PID_9217&REV_0735&MI_00, USB\VID_095D&PID_9217&MI_00}.
            #We split the full string to get just the 2 digit version e.g 19
            $pnpDevice = Get-PnpDevice -PresentOnly -FriendlyName '*HP Video Ingest*' -Class camera -ErrorAction SilentlyContinue
            if ($pnpDevice) {
                $rev = ($pnpDevice.HardwareID | where-object { $_ -match 'REV' }).split('&')[2].split('_')[1]
                $revlen = $rev.Length
                $result = $rev.Substring($revlen - 2)
            }
            else {
                $result = $null  #"NotFound"
            }
            return $result;
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function HPSliceIngestConnected {
        try {
            return $null -ne (Get-PnpDevice -PresentOnly -FriendlyName '*HP Video Ingest*' -Class camera -ErrorAction SilentlyContinue)
        }
        catch { Trace-MTRPException $_ }
    }
    
    
    # Get HP Slice Info using HP Image Assistant
    function Get-HPSliceInfo {
        
        $computerSystem = Get-CimInstance Win32_ComputerSystem
        if ($computerSystem.Model -like "HP Elite Slice G2*") {
    
            Start-MTRPScriptOp -Name "HPSliceInfo" -Type "Process"
            Set-Variable -Name "FileName" -Value "HPImageAssistant.zip"
            $HPImageAssistantURL = "https://agent.rooms.microsoft.com/files/public/softwareupdates/oem/hp/Util/ImageAssistant/hp-hpia-5.1.1.zip"
            $HPIADownloadPath = "C:\WINDOWS\ServiceProfiles\LocalService\AppData\Local\ServicePortalAgent\MTRP\Maintenance\HPImageAssistant"
            $HPIAFolder = $HPIADownloadPath + "\bin"
            $HPIALogsPath = $HPIADownloadPath + "\Logs"    
            $HPIATool = (Get-ChildItem $HPIAFolder -Filter HPImageAssistant.exe -ErrorAction SilentlyContinue).FullName 
            try {
                #check if HPIA is already installed
                if (!($HPIATool)) {
                    if (!(Test-Path $HPIADownloadPath)) {
                        Trace-MTRPTrace "Creating Download folder..."
                        New-Item -ItemType Directory -Path $HPIADownloadPath -Force -InformationAction SilentlyContinue
                    }
                    $packageFile = (join-path $HPIADownloadPath $FileName)
                
                    $transfer = Start-MTRPDownload -Source $HPImageAssistantURL -Destination $packageFile 
                    if ($transfer.success) {
                        Trace-MTRPTrace "HPIA download completed successfully:"
                        $downloaded = $true
                        Expand-MTRPZip -force -Path $packageFile -DestinationPath $HPIAFolder -ErrorAction SilentlyContinue
        
                    }
                }
                else {
                    
                    Trace-MTRPTrace "Found HPIA, continuing with inventory."
                    $downloaded = $true
                }
    
                if ($downloaded -eq $true) {
            
                    $HPIATool = (Get-ChildItem $HPIAFolder -Filter HPImageAssistant.exe).FullName
        
                    Start-process -FilePath $HPIATool -ArgumentList `
                        "/Operation:Analyze", `
                        "/Selection:All", `
                        "/SoftpaqDownloadFolder:$HPIADownloadPath", `
                        "/ReportFolder:$HPIALogsPath", `
                        "/Noninteractive", `
                        "/Debug" `
                        -Wait
    
                    Trace-MTRPTrace "Successfully completed inventory"
        
                }
                
                $HPIAOutputFile = $HPIALogsPath + "\HP Elite Slice G2 with MS SRS.json"
    
                if (Test-Path $HPIAOutputFile) {
                    
                    try {
                        $status = Get-Content $HPIAOutputFile -ErrorAction SilentlyContinue | ConvertFrom-Json
                        #$status = ( -ErrorAction SilentlyContinue | ConvertFrom-Json)
                        if ($null -ne $status) {
                            return $status
                        }
                        else {
                            return "NoData"
                        }
                    }
                    catch {
                        Trace-MTRPException $_
                    }
                
                }
    
            
            }
            catch {
                Trace-MTRPException $_
                Stop-MTRPScriptOp -Name "Download" -Success $false -ResultMessageorCode $_.Exception.Message
                $downloaded = $false
            }
            
    
            Stop-MTRPScriptOp -Name "HPSliceInfo" -Success $true
    
        }
    
    
    }
    
    try { $HPSliceResults = Get-HPSliceInfo } catch {}
    
    #endregion
    #region Combine Properties
    try { $op = Start-MTRPScriptOp -Name "hp" -Type "payload" }catch {}
    $HPPayload = @{
        extensionName = "hp"
        data          = @{
            hpSliceIngestConnected       = HPSliceIngestConnected
            hpSliceIngestFirmwareVersion = HPSliceIngestFirmwareVersion
            hpSliceDrivernFirmwareInfo   = $HPSliceResults.HPIA
        }
    }
    $ScriptContext.Payload += $HPPayload
    try { Stop-MTRPScriptOp -Name "hp" -Success $true }catch {}
    #endregion
    #endregion HP Slice Info

    Write-MTRPLog "Namespace: crestron"
    #region Crestron Info
    #region Functions
    function crestronComputeBios {
        try {
            Return (get-WmiObject Win32_Bios -ErrorAction SilentlyContinue).SMBIOSBIOSVersion
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIintelVideoDriverVersion {
        try {
            return (Get-WmiObject Win32_VideoController -ErrorAction SilentlyContinue).DriverVersion
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelLanVersion {
        try {
            return (Get-NetAdapter -InterfaceDescription *I219*).DriverVersion
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelDriverPkgVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\IntelDriverPackage" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelPkgDisplayVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\IntelDriverPackage" -ErrorAction SilentlyContinue).DisplayVer
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelPkgMeVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\IntelDriverPackage" -ErrorAction SilentlyContinue).MEVer
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelNetworkVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\IntelDriverPackage" -ErrorAction SilentlyContinue).NetworkVer
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronIntelPackVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\IntelDriverPackage" -ErrorAction SilentlyContinue).PackVer
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronCcs400Version {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\CCS-400" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronEnvironmentVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\Environment" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronFirmwareVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\Firmware" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronHdConv200Version {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\HD-CONV-USB-200" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronHdConv250Version {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\HD-CONV-USB-250" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronHuddlyIqVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\Huddly IQ Camera" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function MercuryFwVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\MercuryFWUpdater" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronOsVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\OS" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronRemoteSrvVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\RemoteSrv" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronTswxxx60FwVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\TSWxx60FWUpdater" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronUcsb1FwVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\UC-SB-1 FW" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronUcsb1dfuVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\UC-SB-1-DFU" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function crestronUpdateServerVersion {
        try {
            return (Get-ItemProperty "HKLM:\SOFTWARE\Crestron Electronics Inc.\Packs\UpdateSrv" -ErrorAction SilentlyContinue).Version
        }
        catch {
            Trace-MTRPException $_
        }
    }
    
    function crestronVmaVersion {
        try {
            #Set File Name - may not need the split-path
            $filename = "C:\Progra~1\Crestron\CCS400\User\Logs\UtsEngine.log"
            if (!(Test-Path $filename)) {
                Trace-MTRPTrace "crestronVmaVersion: $filename not found"
                return $null
            }
    
            $vmaFile = Get-Content -Path $filename
            foreach ($v in $vmaFile) {
                if ($v.Contains('Detected Display Dongle:')) {
                    $resultVMA = $v
                }
            }
            $regxVMA = '(?:Detected\sDisplay\sDongle:\s)(?<adapter>[\w\d\s]*)'
            if ($resultVMA -match $regxVMA) {
                $vmaModel = $Matches['adapter']
            }
            return $vmaModel
        }
        catch {
            Trace-MTRPException $_
        }
    }
    
    function crestronMAC {
        try {
            $adapter = Get-WmiObject win32_networkadapterconfiguration | Select-Object description, macaddress | Where-Object Description -match "Ethernet" | Where-Object Description -match "Intel"
            $utsMAC = $adapter.macaddress
            return $utsMAC
        }
        catch {
            Trace-MTRPException $_
        }
    }
    
    function crestronVersionCheckerHDConv200Version {
        try {
            $HDConvCheck = Test-Path "C:\Program Files\Crestron\HD-CONV-USB-200\USB3_Version_Checker.exe"
            if ($HDConvCheck) {
                $HDConvVersion = & 'C:\Program Files\Crestron\HD-CONV-USB-200\USB3_Version_Checker.exe'
                return $HDConvVersion
            }
            
        }
        catch {
            Trace-MTRPException $_
        }
    }
    
    function CrestronFlexDeviceFamily {
        
        try {
            $NUCModel = (Get-WmiObject Win32_Baseboard 'Product').Product
    
            switch ($NUCModel) {
                NUC6i7KYB { $output = "Skull-Canyon" }
                NUC8BEB { $output = "Bean-Canyon" }
                PB60 { $output = "ASUS-PB60" }
    
            }
            return $output
        }
        
        catch {
            Trace-MTRPException $_
        }
        
    } 
    
    function CrestronCustomPage {
        
        try {
    
            $FlexCustomizationFile = "C:\Program Files\Crestron\CCS400\User\Display\*.vtx"
            $UC300CustomizationFile = "C:\Program Files\Crestron\CCS300\User\Display\*.vtx"
    
            if (Test-Path $FlexCustomizationFile) {
                return "CCS400CustomPage"
            }
            elseif (Test-Path $UC300CustomizationFile) {
                return "CCS300CustomPage"
            } 
            else {
                return $null
            }
    
        }
        catch {
            Trace-MTRPException $_
        }
    
        
    }
    
    function GetCrestronUpgradeDevice {
        $output = $null
        try {
            $instanceID = (Get-PnpDevice -FriendlyName "Crestron Upgrade Device" -ErrorAction SilentlyContinue).InstanceID
            if ($instanceID) {
                $pnpProps = Get-PnpDeviceProperty -InstanceId $instanceID -ErrorAction SilentlyContinue
                $output = ($pnpProps | Where-Object Keyname -eq 'DEVPKEY_Device_DriverVersion').Data
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $output
    }

    function GetDelayCRServiceInfo {
        param (
            $ReturnProperty
        )
        try{
            $taskName = "CRService"
            $taskInfo = Get-ScheduledTask | Where-Object {$_.TaskName -like $taskName } | Get-ScheduledTaskInfo
            if($taskInfo){
                return $taskInfo.$ReturnProperty
            }
        }
        catch{ Trace-MTRPException $_}
    }

    function GetCrestronVirtualDisplayCount {
        try{
            $CrestronVirtualDisplayDevices = (get-pnpdevice -friendlyname "crestron virtual touch*"| select friendlyname,hardwareid,instanceid | where instanceid -ne "ROOT\HIDCLASS\0000").instanceid
            return $CrestronVirtualDisplayDevices.count
        } catch{}
        return $null
    }
    
    try {
        $crestronTask = Get-ScheduledTask -TaskName "MTRPDisableCrestronUpgradeDevice" -ErrorAction SilentlyContinue
        $crestronTaskInfo = Get-ScheduledTaskInfo -TaskName "MTRPDisableCrestronUpgradeDevice" -ErrorAction SilentlyContinue
    } catch {}
    

    #endregion
    #region Combine Properties
    if (Test-Path "HKLM:\SOFTWARE\Crestron Electronics Inc.") {
        try { $op = Start-MTRPScriptOp -Name "crestron" -Type "payload" }catch {}
        $crestronPayload = @{
            extensionName = "crestron"
            data          = @{
                crestronConsoleModel                   = Get-MTRPEPCrestronConsoleInfo
                crestronFirmwareVersion                = crestronFirmwareVersion
                crestronFlexDeviceFamily               = CrestronFlexDeviceFamily
                crestronComputeBios                    = crestronComputeBios
                crestronIintelVideoDriverVersion       = crestronIintelVideoDriverVersion
                crestronIntelLanVersion                = crestronIntelLanVersion
                crestronIntelPkgDisplayVersion         = crestronIntelPkgDisplayVersion
                crestronIntelPkgMeVersion              = crestronIntelPkgMeVersion
                crestronIntelNetworkVersion            = crestronIntelNetworkVersion
                crestronIntelPackVersion               = crestronIntelPackVersion
                crestronCcs400Version                  = crestronCcs400Version
                crestronEnvironmentVersion             = crestronEnvironmentVersion
                crestronCustomPage                     = CrestronCustomPage
                crestronHdConv200Version               = crestronHdConv200Version
                crestronHdConv250Version               = crestronHdConv250Version
                crestronHuddlyIqVersion                = crestronHuddlyIqVersion
                MercuryFwVersion                       = MercuryFwVersion
                crestronOsVersion                      = crestronOsVersion
                crestronRemoteSrvVersion               = crestronRemoteSrvVersion
                crestronTswxxx60FwVersion              = crestronTswxxx60FwVersion
                crestronUcsb1FwVersion                 = crestronUcsb1FwVersion
                crestronUcsb1dfuVersion                = crestronUcsb1dfuVersion
                crestronUpdateServerVersion            = crestronUpdateServerVersion
                crestronVmaVersion                     = crestronVmaVersion
                crestronSerialNum                      = Get-MTRPEPCrestronSerialNumber
                crestronMAC                            = crestronMAC
                crestronVersionCheckerHDConv200Version = crestronVersionCheckerHDConv200Version
                crestronUpgradeDeviceVersion           = GetCrestronUpgradeDevice
                disableCrestronUpgradeDeviceTaskState  = $crestronTask.State
                disableCrestronUpgradeDeviceTaskLastRun = $crestronTaskInfo.LastRunTime
                crServiceLastTaskResult                 = GetDelayCRServiceInfo -ReturnProperty LastTaskResult
                crServiceLastRunTime                    = GetDelayCRServiceInfo -ReturnProperty LastRunTime
                crestronVirtualDisplayCount             = GetCrestronVirtualDisplayCount
            }
        }
        $ScriptContext.Payload += $crestronPayload
        try { Stop-MTRPScriptOp -Name "crestron" -Success $true }catch {}
    }
    #endregion
    #endregion Crestron Info

    Write-MTRPLog "Namespace: yealink"
    #region Yealink Info
    function Get-YealinkVersion($model) {
        try {
            $newHKey = New-PSDrive -PSProvider Registry -Name HKU -Root HKEY_USERS -ErrorAction SilentlyContinue
        
            if ($newHKey) {
    
                $outputObj = [PSCustomObject][ordered]@{
                    YealinkFirmwareVersion    = $null 
                    YealinkDeviceVersion      = $null
                    YealinkFirmwareName       = $null
                    YealinkUpgradeFailCnt     = $null
                    YealinkUpgradeFailVersion = $null
                }
    
                $buildpath = "HKU:\S-1-5-18\Software\Yealink\FirmwareUpgradeService\" + $model
                $checkYealinkKey = Test-Path -Path $buildpath
                
                if ($checkYealinkKey) {
                    $YealinkDeviceReg = Get-ItemProperty -Path $buildpath 
        
                    $YealinkFirmwareVersion = $YealinkDeviceReg.FirmwareVersion
                    $YealinkDeviceVersion = $YealinkDeviceReg.DeivceVersion
                    $YealinkFirmwareName = $YealinkDeviceReg.FirmwareName
                    $YealinkUpgradeFailCnt = $YealinkDeviceReg.UpgradeFailCnt
                    $YealinkUpgradeFailVersion = $YealinkDeviceReg.UpgradeFailVersion
    
                    $outputObj = [PSCustomObject][ordered]@{
                        YealinkFirmwareVersion    = $YealinkFirmwareVersion
                        YealinkDeviceVersion      = $YealinkDeviceVersion
                        YealinkFirmwareName       = $YealinkFirmwareName
                        YealinkUpgradeFailCnt     = $YealinkUpgradeFailCnt
                        YealinkUpgradeFailVersion = $YealinkUpgradeFailVersion
                    }
                    return $outputObj
                }
            }
        
        }
        catch {
            Trace-MTRPException $_
        }
        
    }
    
    function GetUVC40Info {
        try {
            #UVC40
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B035*") {
                $UVC40Info = Get-YealinkVersion UVC40
            }
        }
        catch {
            Trace-MTRPException $_
        }
        
        return $UVC40Info
    }
    
    function GetUVC30Info {
    
        try {
            #UVC30
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B019*") {
                $UVC30Info = Get-YealinkVersion UVC30
    
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $UVC30Info
    
    }
    
    function GetUVC50Info {
    
        try {
            #UVC50
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B00B*") {
                $UVC30Info = Get-YealinkVersion UVC50
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $UVC50Info
    
    }
    
    function GetUVC80Info {
    
        try {
            #UVC80
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B00A*") {
                $UVC80Info = Get-YealinkVersion UVC80
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $UVC80Info
    
    }
    
    
    function GetUVC84Info {
    
        try {
            #UVC84
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B04E*") {
                $UVC84Info = Get-YealinkVersion UVC84
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $UVC84Info
    
    }
    
    
    function GetCP900Info {
    
        try {
            #CP900
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B009*") {
                $CP900Info = Get-YealinkVersion CP900
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $CP900Info
    
    }
    
    function GetMTouchIIInfo {
    
        try {
            #MTouchII
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B032*") {
                $MTouchIIInfo = Get-YealinkVersion MTouchII
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $MTouchIIInfo
    
    }
    
    function GetCameraHubInfo {
    
        try {
            #CameraHub
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B00F*") {
                $CameraHubInfo = Get-YealinkVersion CameraHub
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $CameraHubInfo
    
    }
    
    function GetMSpeechInfo {
    
        try {
            #MSpeech
            if ($pnpdevices.HardwareID -like "*VID_6993&PID_B043*") {
                $MSpeechInfo = Get-YealinkVersion MSpeech
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $MSpeechInfo
    
    }
    
    #region Combine Properties
    try {
    
        try { $op = Start-MTRPScriptOp -Name "yealink" -Type "payload" }catch {}
        $pnpdevices = Get-PnpDevice -PresentOnly -ErrorAction SilentlyContinue
    
        $yealinkPayload = @{
            extensionName = "yealink"
            data          = @{
                UVC40FirmwareVersion     = (GetUVC40Info).YealinkFirmwareVersion
                UVC40DeviceVersion       = (GetUVC40Info).YealinkDeviceVersion
                UVC30FirmwareVersion     = (GetUVC30Info).YealinkFirmwareVersion
                UVC30DeviceVersion       = (GetUVC30Info).YealinkDeviceVersion
                UVC50FirmwareVersion     = (GetUVC50Info).YealinkFirmwareVersion
                UVC50DeviceVersion       = (GetUVC50Info).YealinkDeviceVersion
                UVC80FirmwareVersion     = (GetUVC80Info).YealinkFirmwareVersion
                UVC80DeviceVersion       = (GetUVC80Info).YealinkDeviceVersion
                UVC84FirmwareVersion     = (GetUVC84Info).YealinkFirmwareVersion
                UVC84DeviceVersion       = (GetUVC84Info).YealinkDeviceVersion
                CP900FirmwareVersion     = (GetCP900Info).YealinkFirmwareVersion
                CP900DeviceVersion       = (GetCP900Info).YealinkDeviceVersion
                MTouchIIFirmwareVersion  = (GetMTouchIIInfo).YealinkFirmwareVersion
                MTouchIIDeviceVersion    = (GetMTouchIIInfo).YealinkDeviceVersion
                MSpeechFirmwareVersion   = (GetMSpeechInfo).FirmwareVersion
                MSpeechDeviceVersion     = (GetMSpeechInfo).YealinkDeviceVersion
                CameraHubFirmwareVersion = (GetCameraHubInfo).YealinkDeviceVersion
                CameraHubDeviceVersion   = (GetCameraHubInfo).YealinkDeviceVersion
                
            }
        }
        $ScriptContext.Payload += $yealinkPayload
        try { Stop-MTRPScriptOp -Name "yealink" -Success $true }catch {}
        
    
    }
    catch {
        Trace-MTRPException $_
        $ResultSuccess = $false
        $ResultCode = "Failed"
    }
    #endregion
    #endregion Yealink Info

    Write-MTRPLog "Namespace: jabra"
    #region Jabra Info
    
    #Gets Jabra InstanceID
    function getInstanceID ($JabraModel) {
    
    
        switch ($JabraModel) {
            "Panacast50" {
                $instanceId = $pnpdevices | 
                Where-Object InstanceId -like '*VID_0B0E&PID_3012*' | 
                Where-Object Class -eq 'USB'  | 
                Select-Object -first 1 -ExpandProperty InstanceId  
            }
    
            "Panacast" {
                $instanceId = $pnpdevices | 
                Where-Object InstanceId -like '*VID_2B93&PID_[0|8]003*' | 
                Where-Object Class -eq 'USB'  | 
                Select-Object -first 1 -ExpandProperty InstanceId
            }
            "Speak750" {
                $instanceId = $pnpdevices | 
                Where-Object InstanceId -like '*VID_0B0E&PID_24B0*' | 
                Where-Object Class -eq 'USB'  | 
                Select-Object -first 1 -ExpandProperty InstanceId
            }
            Default {}
        }
    
        return $instanceId
    
    }
    
    #Checks to see if the Jabra Firmware utility is installed
    function checkJabraInstaller {
        try {
            $software = "Jabra MTRP Firmware Update"
            $installed = $null -ne (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object { 
                    $_.DisplayName -like "*$($software)*" -and 
                    $_.DisplayVersion -and $_.DisplayVersion -ge "1.1.1.49905"
                })
    
            If (-Not $installed) {
                
                return "NotInstalled"
        
            }
            else {
                return "Installed"
            }
        }
        catch {
            Trace-MTRPException $_
        }
    }
    
    # Executes the Jabra utility to find the current version installed on the device
    function CheckJabraVersion($instanceId) {
        try {
    
            Trace-MTRPTrace "Checking current firmware version."
    
            $InstallerPath = "C:\Program Files (x86)\Jabra\MTRP"
            $jabraHeadlessFirmwareUpdater = (Get-ChildItem $InstallerPath -Filter JabraCmdlineFwUpdater.exe).FullName
        
            $deviceVersion = & $jabraHeadlessFirmwareUpdater -firmwareversion -instanceid $instanceId
            $deviceVersion = $deviceVersion
        }
        catch {
            Trace-MTRPException $_
        }
        
        return $deviceVersion
    }
    
    
    #This is the brain of the Jabra info namespace. 
    # It Checks if the installer is downloaded, if not it downloads it then executes the firmware utility to read the version information
    function Get-JabraVersion($instanceId) {
        try {
    
            $LogsDir = "C:\WINDOWS\ServiceProfiles\LocalService\AppData\Local\ServicePortalAgent\MTRP\Logs"
            $DownloadPath = "C:\WINDOWS\ServiceProfiles\LocalService\AppData\Local\ServicePortalAgent\MTRP\Updates\Jabra"
    
            $JabraUpdateUtil = "https://agent.rooms.microsoft.com/files/public/softwareupdates/oem/jabra/util/JabraMtrpInstaller_1.1.1.zip"
    
            if (!(Test-Path $DownloadPath)) {
                Trace-MTRPTrace "Creating Firmware Download folder..."
                New-Item -ItemType Directory -Path $DownloadPath -Force -InformationAction SilentlyContinue -ErrorAction SilentlyContinue
            }
        
            if (!(Test-Path $LogsDir)) {
                New-Item -ItemType Directory -Path $LogsDir -Force -InformationAction SilentlyContinue -ErrorAction SilentlyContinue
            }
                
            $GetJabraInstallerStatus = checkJabraInstaller
        
            if ($GetJabraInstallerStatus -eq "Installed") {
                Trace-MTRPTrace "Found Jabra MTRP Installer."
                $JBInstalled = $true
            }
            
            else {
                Trace-MTRPTrace "Missing Jabra MTRP Installer, will download and install this prereq."
        
                $InstallerFile = (join-path $DownloadPath ("JabraMTRPInstaller" + ".zip"))
                try {
                    Trace-MTRPTrace "Starting Jabra MTRP Install Utility Download."
                    $transfer = Start-MTRPDownload -Source $JabraUpdateUtil -Destination $InstallerFile
                    if ($transfer.success) {
                        Trace-MTRPTrace "Download complete $($InstallerFile)"
                        $Jabrautildownload = $true
                        Expand-MTRPZip -Path $InstallerFile -DestinationPath $DownloadPath -Force 
                        Trace-MTRPTrace "Successfully expanded archive."
                        Remove-Item $InstallerFile -Force
                    }
                    else {
                        Trace-MTRPTrace "Jabra Installer Utility failed."
                        return
                    }
            
                }
                catch {
                    Trace-MTRPException $_
                    $downloadError += $_.Exception.Message
                }
        
                if ($Jabrautildownload) {
        
                    $InstallerFile = (Get-ChildItem $DownloadPath -Filter *.msi).FullName 
        
                
                    $logfile = $LogsDir + "\" + "JabraUpdateUtil" + "_" + (Get-Date -UFormat "%Y-%m-%dT%H.%M.%S%Z").tostring() + ".log"
        
                    $MSIArguments = @(
                        "/i"
                        ('"{0}"' -f $InstallerFile)
                        "/qn"
                        "/norestart"
                        "/L*v"
                        $logFile
                    )
        
                    Start-Process "msiexec.exe" -ArgumentList $MSIArguments -Wait -NoNewWindow
                
                }
        
                Start-Sleep -Seconds 60
    
                $GetJabraInstallerStatus = checkJabraInstaller
                
                if ($GetJabraInstallerStatus -eq "Installed") {
                    Trace-MTRPTrace "Found Jabra MTRP Installer."
                    $JBInstalled = $true
                }
                else {
                    Trace-MTRPTrace "Failed to install Jabra MTRP Installer."
                    return
                }
        
            }
    
    
            if ($JBInstalled) {
    
                #Execute the version checker
    
                $CurrentVersion = CheckJabraVersion $instanceId
            
            }
    
            return $CurrentVersion
    
        }
    
        catch {
            Trace-MTRPException $_
        }
    }

    #region Jabra functions
    # Jabra Panacast 50 firmware function
    # Function finds the InstanceID then feeds that to the Jabra update utility
    function GetJabraPanacast50Info {
        try {
            #JabraP50Firmware
            if (($pnpdevices.HardwareID -like "*$($Panacast50PIDVID1)*") -or ($pnpdevices.HardwareID -like "*$($Panacast50PIDVID2)*")) {
                $instanceId = getInstanceID Panacast50
                $JabraPanacast50Info = Get-JabraVersion $instanceId
    
            }
            else {
                $JabraPanacast50Info = $null
    
            }
        }
        catch {
            Trace-MTRPException $_
        }
        
        return $JabraPanacast50Info
    }
    
    # Jabra Panacast firmware function
    function GetJabraPanacastInfo {
    
        try {
            #JabraPanacast
            if (($pnpdevices.HardwareID -like "*$($PanacastPIDVIDwAudio)*") -or ($pnpdevices.HardwareID -like "*$($PanacastPIDVIDwithoutAudio)*") ) {
                $instanceId = getInstanceID Panacast
                $JabraPanacastInfo = Get-JabraVersion $instanceId
    
            }
            else {
                $JabraPanacastInfo = $null
    
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $JabraPanacastInfo
    
    }
    
    # Jabra JabraSpeak750 firmware function
    function GetJabraSpeak750Info {
    
        try {
            #JabraSpeak750
            if (($pnpdevices.HardwareID -like "*$($Speak750PIDVID)*")) {
                $instanceId = getInstanceID Panacast
                $JabraSpeak750Info = Get-JabraVersion $instanceId
            }
            else {
                $JabraSpeak750Info = $null
            }
        }
        catch {
            Trace-MTRPException $_
        }
        return $JabraSpeak750Info
    
    }
    
    
    #endregion
    #region Combine Properties
    try {
        #This EP runs the Jabra update utility to collect firmware info on Jabra devices
        #To add new devices, add the PIDVID for the device and a function for the device
    
        try { $op = Start-MTRPScriptOp -Name "jabra" -Type "payload" }catch {}
        $pnpdevices = Get-PnpDevice -PresentOnly -ErrorAction SilentlyContinue
        $Panacast50PIDVID1 = "VID_0B0E&PID_3012"
        $Panacast50PIDVID2 = "VID_0B0E&PID_3013"
        $PanacastPIDVIDwAudio = "VID_2B93&PID_[0|8]003"
        $PanacastPIDVIDwithoutAudio = "VID_0x2B93&PID_0x[0|8]003"
        $Speak750PIDVID = "VID_0B0E&PID_24B0"
        
        $JabraDevice = ($pnpdevices | where-object { $_.Friendlyname -like "*Jabra*" })
    
        if ($JabraDevice) {
            $jabraPayload = @{
                extensionName = "jabra"
                data          = @{
                    JabraSpeak750Firmware   = GetJabraSpeak750Info
                    JabraPanacast50Firmware = GetJabraPanacast50Info
                    JabraPanacastFirmware   = GetJabraPanacastInfo
                    
                }
            }
            $ScriptContext.Payload += $jabraPayload
        }
        
    
        try { Stop-MTRPScriptOp -Name "jabra" -Success $true }catch {}
        
    
    }
    catch {
        Trace-MTRPException $_
        $ResultSuccess = $false
        $ResultCode = "Failed"
    }
    
    #endregion
    #endregion Jabra Info

    Write-MTRPLog "Namespace: mtrpinfo"
    #region Admin Ring config
    function AdminRing {
        try {
            return (Get-ItemProperty "HKLM:\Software\Microsoft\MTRP\Updates" -ErrorAction SilentlyContinue).AdminRing
        }
        catch {
            Write-Host "AdminRing: $($_.Exception)"
            Trace-MTRPException $_
        }
    }
    
    function adminRingLastUpdated {
        try {
            return (Get-ItemProperty "HKLM:\Software\Microsoft\MTRP\Updates" -ErrorAction SilentlyContinue).AdminRingLastUpdateTime
        }
        catch {
            Write-Host "adminRingLastUpdated: $($_.Exception)"
            Trace-MTRPException $_
        }
    }

    function ForceNightlyTasks {
        try{
            return (Get-MTRPRegValue -path 'HKLM:\Software\Microsoft\MTRP' -Name 'ForceNightlyTasks') -eq '1'
        }
        catch{
            Write-MTRPLog "ForceNightlyTasks: $($_.Exception)"
            Trace-MTRPException $_
        }
    }
    
    
    #region Combine Properties
    $trackingRegPath = "HKLM:\Software\Microsoft\MTRP\Updates"
    if (Test-Path $trackingRegPath) {
        try { $op = Start-MTRPScriptOp -Name "mtrpinfo" -Type "payload" }catch {}
        $mtrpPayload = @{
            extensionName = "mtrpinfo"
            data          = @{
                epURL                   = $ScriptContext.Vars.EPUrl
                epScriptRevision        = $scriptRevision.ToString()
                adminRing               = AdminRing
                adminRingLastUpdated    = adminRingLastUpdated
                powerShellModulesLoaded = Get-MTRPEPManagedServicesModulesLoaded
                ForceNightlyTasks       = ForceNightlyTasks
            }
        }
        $ScriptContext.Payload += $mtrpPayload
        try { Stop-MTRPScriptOp -Name "mtrpinfo" -Success $true }catch {}
    }
    #endregion
    #endregion Admin Ring config

    Write-MTRPLog "Namespace: mtrappstatus"
    #region MTRApp Properties
    function getMtrAppState {
        try {
            $status = (Get-MTRPMTRAppStatus -ErrorAction SilentlyContinue | ConvertFrom-Json).response.data.currentState
            if ($null -ne $status) {
                return $status
            }
            else {
                return "NoData"
            }
        }
        catch {
            Trace-MTRPException $_
        }
        
    }

    function getSkypeMrxPrompt {
        try {
            $currentMTRApp = (Get-AppxProvisionedPackage -Online | Where-Object { $_.DisplayName -eq "Microsoft.SkypeRoomSystem" } | Sort-Object Version -Descending | Select-Object -First 1).Version
            $isSkypeUserLoggedIn = ((Get-WMIObject -class Win32_ComputerSystem -Property username -EA 0 | `
                        Select-Object -ExpandProperty UserName ) -split "\\" | Select-Object -Skip 1 -First 1) -eq "skype"
            $skypeSID = (Get-WmiObject Win32_UserAccount -Filter "Name='Skype' AND Domain='$($env:COMPUTERNAME)'").SID
            $baseSkypeRegPath = "Registry::HKEY_USERS\$skypeSID"       
            if (!$isSkypeUserLoggedIn) {
                # Skype user not logged, We need to load the registry to the Skype user
                reg load HKLM\SkypeClasses "C:\Users\Skype\AppData\Local\Microsoft\Windows\UsrClass.dat" | Out-Null
                $baseSkypeRegPath = "HKLM:\SkypeClasses"
            }
            if (Test-Path "$baseSkypeRegPath\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages\Microsoft.SkypeRoomSystem_$($currentMTRApp)_x64__8wekyb3d8bbwe\App\Capabilities\URLAssociations") {
                $result = $false
            }
            else {
                $result = $true
            }
            if (!$isSkypeUserLoggedIn) {
                # No skype user logged in, we need to unload the reg 
                [gc]::collect()
                reg unload HKLM\SkypeClasses | Out-Null
            }
        }
        catch {
            $result = $null
        }
        return $result
    }

    try { $op = Start-MTRPScriptOp -Name "mtrpappstatus" -Type "payload" }catch {}
    $mtrpAppPayload = @{
        extensionName = "mtrappstatus"
        data          = @{
            currentState = getMtrAppState 
            skypeMrxPrompt = getSkypeMrxPrompt
            SystemAppInstallCount = (Get-AppxPackage Microsoft.SkypeRoomSystem).count
            SkypeAppInstallCount = (Get-AppxPackage Microsoft.SkypeRoomSystem -User Skype).count
        }
    }
    $ScriptContext.Payload += $mtrpAppPayload
    try { Stop-MTRPScriptOp -Name "mtrpappstatus" -Success $true }catch {}
    #endregion MTRApp Properties

    Write-MTRPLog "Namespace: network"
    #region Network
    function isMMRNetCaptureRunning {
        try {
            $NetEventSession = Get-NetEventSession | where-object name -eq "MMRNetCap"
            if ($null -eq $NetEventSession ) {
                return $false
            }
            else {
                return $true
            }
        }
        catch {
            Trace-MTRPException $_
        }
    }
    function isNetEventSessionRunning {
        try {
            $NetEventSession = Get-NetEventSession
            if ($null -eq $NetEventSession ) {
                return $false
            }
            else {
                return $true
            }
        }
        catch {
            Trace-MTRPException $_
        }
    }

    function Test-ProxyRestore {
        $toReturn = [PSCustomObject]@{
            RunningOver48Hours = $null
            LogFileExists = $null
            TaskDeleted = $null
            TaskExists = $null
            ProxyRestoreDate = $null
            ProxyListValidation = $null
            ProxyAutoconfigUrlValidation = $null
            ProxyBypassValidation = $null
            ProxyAutoDetectValidation = $null
        }
        try {
            
            $toReturn.ProxyRestoreDate = Get-MTRPRegValue -Path 'HKLM:\Software\Microsoft\MTRP' -Name 'ProxyRestoreDate'
            $toReturn.ProxyListValidation = Get-MTRPRegValue -Path 'HKLM:\Software\Microsoft\MTRP' -Name 'ProxyListValidation'
            $toReturn.ProxyAutoconfigUrlValidation = Get-MTRPRegValue -Path 'HKLM:\Software\Microsoft\MTRP' -Name 'ProxyAutoconfigUrlValidation'
            $toReturn.ProxyBypassValidation = Get-MTRPRegValue -Path 'HKLM:\Software\Microsoft\MTRP' -Name 'ProxyBypassValidation'
            $toReturn.ProxyAutoDetectValidation = Get-MTRPRegValue -Path 'HKLM:\Software\Microsoft\MTRP' -Name 'ProxyAutoDetectValidation'

            $filePath = "C:\Rigel\ProxyRestore_Log.log"
            if (Test-Path $filePath){
                $toReturn.LogFileExists = $true
                $Item = (Get-Item $filePath)
                # Get the file's creation and modified times
                $creationTime = $Item.CreationTime
                $modifiedTime = $item.LastWriteTime
            
                # Calculate the time difference
                $timeDifference = $modifiedTime - $creationTime
            
                # Check if the difference is greater than 48 hours
                if ($timeDifference.TotalHours -gt 48) {
                    $toReturn.RunningOver48Hours = $true
                }
                else {
                    $toReturn.RunningOver48Hours = $false
                }
            } 
            else {
                $toReturn.LogFileExists = $false
            }

            $taskName = "MTRPProxyRestore"
            # Check if the task exists
            if (Get-ScheduledTask $taskName -ErrorAction SilentlyContinue) {
                $toReturn.TaskExists = $true

                if ($toReturn.RunningOver48Hours -eq $true) {
                    try {
                        # Attempt to unregister the task
                        Unregister-ScheduledTask -TaskName $taskName -Confirm:$false
                        $toReturn.TaskDeleted = $true
                    } catch {
                        $toReturn.TaskDeleted = $false
                        Trace-MTRPException $_
                        Write-MTRPLog "Task $taskName unregister failed."
                    }
                }
            } else {
                $toReturn.TaskExists = $false
                Write-MTRPLog "Task $taskName does not exist."
            }
            
        }
        catch {
            Trace-MTRPException $_
        }
        return $toReturn
    }
        
    try { $op = Start-MTRPScriptOp -Name "network" -Type "payload" }catch {}
    $proxyConfigRaw = Test-MTRPProxyConfig
    $proxyConfig = $proxyConfigRaw | Select-Object @{ E = { $_.TestResult }; N = "Status" }, 
    @{ E = { if (-not $_.AdditionalInfo.SystemProxyServer) {"NA"} else {$_.AdditionalInfo.SystemProxyServer} }; N = "SystemProxyServer" }, 
    @{ E = { if (-not $_.AdditionalInfo.SystemProxyPAC) {"NA"} else {$_.AdditionalInfo.SystemProxyPAC} }; N = "SystemProxyPAC" }, 
    @{ E = { if (-not $_.AdditionalInfo.SkypeProxyServer) {"NA"} else {$_.AdditionalInfo.SkypeProxyServer} }; N = "SkypeProxyServer" }, 
    @{ E = { if (-not $_.AdditionalInfo.SkypeProxyPAC) {"NA"} else {$_.AdditionalInfo.SkypeProxyPAC} }; N = "SkypeProxyPAC" },
    @{ E = { if (-not $_.AdditionalInfo.SystemProxyBypass) {"NA"} else {$_.AdditionalInfo.SystemProxyBypass} }; N = "SystemProxyBypass" }
    @{ E = { if (-not $_.AdditionalInfo.SystemProxyUsage) {"NA"} else {$_.AdditionalInfo.SystemProxyBypass} }; N = "SystemProxyUsage" }

    $WifiInformation = Get-MTRPEPWiFiInformation
    $proxyRestoreTaskInfo = Test-ProxyRestore
    $networkPayload = @{
        extensionName = "network"
        data          = @{
            isMMRNetCaptureRunning   = isMMRNetCaptureRunning
            isNetEventSessionRunning = isNetEventSessionRunning
            proxyConfig              = $proxyConfig
            NetworkTestResults       = $NetworkTestResults
            WiFiSSID                 = $WifiInformation.WirelessSSID
            WifiStrength             = $WifiInformation.WirelessStrength
            WiFiStrengthSample       = Get-MTRPEPWifiStrengthSampled
            ProxyRestoreTaskOver48h  = $proxyRestoreTaskInfo.RunningOver48Hours
            ProxyRestoreLogFileExists= $proxyRestoreTaskInfo.LogFileExists
            ProxyRestoreTaskDeleted  = $proxyRestoreTaskInfo.TaskDeleted    
            ProxyRestoreTaskExists   = $proxyRestoreTaskInfo.TaskExists
            ProxyRestoreDate         = $proxyRestoreTaskInfo.ProxyRestoreDate
            ProxyListValidation      = $proxyRestoreTaskInfo.ProxyListValidation
            ProxyAutoconfigUrlValidation = $proxyRestoreTaskInfo.ProxyAutoconfigUrlValidation
            ProxyBypassValidation    = $proxyRestoreTaskInfo.ProxyBypassValidation
            ProxyAutoDetectValidation= $proxyRestoreTaskInfo.ProxyAutoDetectValidation
        }
    }
    $ScriptContext.Payload += $networkPayload
    try { Stop-MTRPScriptOp -Name "network" -Success $true }catch {}
    #endregion Network

    Write-MTRPLog "Namespace: security"
    #region Security namespace and function

    function Test-DefaultMtrPassword() {
        try {
            $password = ConvertTo-SecureString 'sfb' -AsPlainText -Force
            [pscredential]$credOject = New-Object System.Management.Automation.PSCredential ("Admin", $password)
            Start-Process -filepath "powershell.exe" -Credential $credOject -ArgumentList "-scriptblock {get-date}" -WorkingDirectory 'C:\Windows\System32'
            return $true
        }
        catch {
            return $false
        }
    }

    try { $op = Start-MTRPScriptOp -Name "security" -Type "payload" }catch {}
        
    $adminUserInfo = $null
    $MtrAdminIsDefaultPassword = $false
    

    $adminUserInfo = Get-MTRPEPDefaultMtrAdminUserInfo
    $MtrAdminIsDefaultPassword = $adminUserInfo.IsDefaultPassword
    if(Test-MTRPFeatureFlag -featureName "USB-Drive-Tracker" -predicate $MTRPID -config $featureconfig)
        {$USBDriveTracker = Invoke-MTRPEPUSBDriveTracker}
    


    $securityPayload = @{
        extensionName = "security"
        data          = @{
            AdminUserPresent           = ($null -ne $adminUserInfo)
            UsingDefaultAdmin          = $MtrAdminIsDefaultPassword
            RequireDeviceEncryption    = Get-MTRPWindowsCSP -ClassName "MDM_Bitlocker" -Property "RequireDeviceEncryption"
            RequireSecureBoot          = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_DeviceGuard01" -Property "VirtualizationBasedSecurityHwReq"
            SecureBootState            = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus" -Property "SecureBootState"
            OSVersion                  = Get-MTRPWindowsCSP -ClassName "MDM_DevDetail" -Property "SwV"
            EncryptionActive           = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Compliance01" -Property "EncryptionCompliance"
            FirewallStatus             = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Firewall01" -Property "Status"
            TPMStatus                  = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_TPM01" -Property "SpecificationVersion"
            AntivirusProduct           = Get-MTRPAntivirusProduct
            AntivirusStatus            = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Antivirus01" -Property "Status"
            AntivirusSignatureStatus   = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Antivirus01" -Property "SignatureStatus"
            AntispywareStatus          = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Antispyware01" -Property "Status"
            AntispywareSignatureStatus = Get-MTRPWindowsCSP -ClassName "MDM_DeviceStatus_Antispyware01" -Property "SignatureStatus"
            AllowRealtimeMonitoring    = Get-MTRPWindowsCSP -ClassName "MDM_Policy_Result01_Defender02" -Property "AllowRealtimeMonitoring"
            USBDriveLongestConnectedMinutes = $USBDriveTracker.ConnectionDuration
            USBDriveLongestConnectedName = $USBDriveTracker.FriendlyName 
        }
    }
    $ScriptContext.Payload += $securityPayload
        
    try { Stop-MTRPScriptOp -Name "security" -Success $true }
    catch {}
    #endregion Security namespace and function

    Write-MTRPLog "Namespace: Preview.Telemetry.Device_W.Performance.Thermal_L"
    #region Preview.Telemetry.Device_W.Performance.Thermal_L Namespace - Combine Properties
    try { $op = Start-MTRPScriptOp -Name "Preview.Telemetry.Device_W.Performance.Thermal_L" -Type "Process" }catch {}
    try {$perfTemps = Get-MTRPEPPerfThermalZoneTemp} catch {}
    $perfTempuratureListPayload = @{
        extensionName = "Preview.Telemetry.Device_W.Performance.Thermal_L"
        data          = $perfTemps
    }
    $ScriptContext.Payload += $perfTempuratureListPayload
    try { Stop-MTRPScriptOp -Name "Preview.Telemetry.Device_W.Performance.Thermal_L" -Success $true }catch {}
    #endregion Preview.Telemetry.Device_W.Performance.Thermal_L Namespace - Combine Properties

    Write-MTRPLog "Namespace: Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L"
    #region Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L Namespace - Combine Properties
    try { $op = Start-MTRPScriptOp -Name "Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L" -Type "Process" }catch {}
    try {$driverCrashCounts = Get-MTRPEPDriverCrashCounts} catch {}
    $driverCrashCountsListPayload = @{
        extensionName = "Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L"
        data          = $driverCrashCounts
    }
    $ScriptContext.Payload += $driverCrashCountsListPayload
    try { Stop-MTRPScriptOp -Name "Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L" -Success $true }catch {}
    #endregion Preview.Telemetry.Device_W.Performance.DriverCrashCounts_L Namespace - Combine Properties    
    
    #region Preview.Telemetry.Device_W.ECS.Changes_B
    $SkypeECS = "C:\Users\Skype\AppData\Local\Packages\Microsoft.SkypeRoomSystem_8wekyb3d8bbwe\LocalCache\Roaming\Microsoft\Teams\settings.json"
    $LastECS = "C:\Rigel\EBak.json"

    function CheckECSChanges() {
        $changes = $null

        if((Test-Path  $LastECS)) {
            $changes = Find-MTRPJsonDifferences -File1  $LastECS -File2 $SkypeECS
            Copy-Item $SkypeECS $LastECS -Force
        } 
        elseif((Test-Path $SkypeECS)) {
            Copy-Item $SkypeECS $LastECS -Force
        }
        else {
            Trace-MTRPEvent "CheckECSChanges: Teams settings.json not found"
        }

        return $changes
    }

    if(Test-MTRPFeatureFlag -featureName "ECS-Changes" -predicate $MTRPID -config $featureconfig){
        Write-MTRPLog "Namespace: Preview.Telemetry.Device_W.ECS.Changes_B"
        try { $op = Start-MTRPScriptOp -Name "Preview.Telemetry.Device_W.ECS.Changes_B" -Type "Process" }catch {}
        try {$ecsChanges = CheckECSChanges} catch { Trace-MTRPException $_}
        $ecsChangesPayload = @{
            extensionName = "Preview.Telemetry.Device_W.ECS.Changes_B"
            data          = $ecsChanges
        }
        $ScriptContext.Payload += $ecsChangesPayload
        try { Stop-MTRPScriptOp -Name "Preview.Telemetry.Device_W.ECS.Changes_B" -Success $true }catch {}
    }
    #endregion Preview.Telemetry.Device_W.ECS.Changes_B


    #endregion Run EP
}
catch {
    if ($ScriptContext.IsBootstrap) {
        $ScriptContext.TelemetryHelper.Exception = $_
        Start-MTRPBCatch
    }
    else {
        # Collect all useful information from the exception message for output
        $ExceptionOutput = @{}
        @($_, $_.Exception, $_.InvocationInfo) | ForEach-Object {
            $_.PSObject.Properties | Where-Object { -not [string]::IsNullOrEmpty($_.Value) } | ForEach-Object {
                $ExceptionOutput[$_.Name] = $_.Value
            }
        }

        Write-Host ([PSCustomObject]$ExceptionOutput | Out-String).Trim()
    }
}
finally {
    if ($ScriptContext.IsBootstrap) {
        Start-MTRPBClose
    }
    else {
        if ($ScriptContext.PayloadActions) { &$ScriptContext.PayloadActions }
        if ($TranscriptPath -and (Test-Path $TranscriptPath)) {
            Stop-Transcript -ErrorAction SilentlyContinue | Out-Null
        }
    }
}

# SIG # Begin signature block
# MIIoKgYJKoZIhvcNAQcCoIIoGzCCKBcCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCDBcShpJuQG7gfN
# zRbl36OyH5H8baU/dGgggpuWy27NEqCCDXYwggX0MIID3KADAgECAhMzAAADrzBA
# DkyjTQVBAAAAAAOvMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNVBAYTAlVTMRMwEQYD
# VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25p
# bmcgUENBIDIwMTEwHhcNMjMxMTE2MTkwOTAwWhcNMjQxMTE0MTkwOTAwWjB0MQsw
# CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9u
# ZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMR4wHAYDVQQDExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
# AQDOS8s1ra6f0YGtg0OhEaQa/t3Q+q1MEHhWJhqQVuO5amYXQpy8MDPNoJYk+FWA
# hePP5LxwcSge5aen+f5Q6WNPd6EDxGzotvVpNi5ve0H97S3F7C/axDfKxyNh21MG
# 0W8Sb0vxi/vorcLHOL9i+t2D6yvvDzLlEefUCbQV/zGCBjXGlYJcUj6RAzXyeNAN
# xSpKXAGd7Fh+ocGHPPphcD9LQTOJgG7Y7aYztHqBLJiQQ4eAgZNU4ac6+8LnEGAL
# go1ydC5BJEuJQjYKbNTy959HrKSu7LO3Ws0w8jw6pYdC1IMpdTkk2puTgY2PDNzB
# tLM4evG7FYer3WX+8t1UMYNTAgMBAAGjggFzMIIBbzAfBgNVHSUEGDAWBgorBgEE
# AYI3TAgBBggrBgEFBQcDAzAdBgNVHQ4EFgQURxxxNPIEPGSO8kqz+bgCAQWGXsEw
# RQYDVR0RBD4wPKQ6MDgxHjAcBgNVBAsTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEW
# MBQGA1UEBRMNMjMwMDEyKzUwMTgyNjAfBgNVHSMEGDAWgBRIbmTlUAXTgqoXNzci
# tW2oynUClTBUBgNVHR8ETTBLMEmgR6BFhkNodHRwOi8vd3d3Lm1pY3Jvc29mdC5j
# b20vcGtpb3BzL2NybC9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3JsMGEG
# CCsGAQUFBwEBBFUwUzBRBggrBgEFBQcwAoZFaHR0cDovL3d3dy5taWNyb3NvZnQu
# Y29tL3BraW9wcy9jZXJ0cy9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3J0
# MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQELBQADggIBAISxFt/zR2frTFPB45Yd
# mhZpB2nNJoOoi+qlgcTlnO4QwlYN1w/vYwbDy/oFJolD5r6FMJd0RGcgEM8q9TgQ
# 2OC7gQEmhweVJ7yuKJlQBH7P7Pg5RiqgV3cSonJ+OM4kFHbP3gPLiyzssSQdRuPY
# 1mIWoGg9i7Y4ZC8ST7WhpSyc0pns2XsUe1XsIjaUcGu7zd7gg97eCUiLRdVklPmp
# XobH9CEAWakRUGNICYN2AgjhRTC4j3KJfqMkU04R6Toyh4/Toswm1uoDcGr5laYn
# TfcX3u5WnJqJLhuPe8Uj9kGAOcyo0O1mNwDa+LhFEzB6CB32+wfJMumfr6degvLT
# e8x55urQLeTjimBQgS49BSUkhFN7ois3cZyNpnrMca5AZaC7pLI72vuqSsSlLalG
# OcZmPHZGYJqZ0BacN274OZ80Q8B11iNokns9Od348bMb5Z4fihxaBWebl8kWEi2O
# PvQImOAeq3nt7UWJBzJYLAGEpfasaA3ZQgIcEXdD+uwo6ymMzDY6UamFOfYqYWXk
# ntxDGu7ngD2ugKUuccYKJJRiiz+LAUcj90BVcSHRLQop9N8zoALr/1sJuwPrVAtx
# HNEgSW+AKBqIxYWM4Ev32l6agSUAezLMbq5f3d8x9qzT031jMDT+sUAoCw0M5wVt
# CUQcqINPuYjbS1WgJyZIiEkBMIIHejCCBWKgAwIBAgIKYQ6Q0gAAAAAAAzANBgkq
# hkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
# EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
# bjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5
# IDIwMTEwHhcNMTEwNzA4MjA1OTA5WhcNMjYwNzA4MjEwOTA5WjB+MQswCQYDVQQG
# EwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwG
# A1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQg
# Q29kZSBTaWduaW5nIFBDQSAyMDExMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
# CgKCAgEAq/D6chAcLq3YbqqCEE00uvK2WCGfQhsqa+laUKq4BjgaBEm6f8MMHt03
# a8YS2AvwOMKZBrDIOdUBFDFC04kNeWSHfpRgJGyvnkmc6Whe0t+bU7IKLMOv2akr
# rnoJr9eWWcpgGgXpZnboMlImEi/nqwhQz7NEt13YxC4Ddato88tt8zpcoRb0Rrrg
# OGSsbmQ1eKagYw8t00CT+OPeBw3VXHmlSSnnDb6gE3e+lD3v++MrWhAfTVYoonpy
# 4BI6t0le2O3tQ5GD2Xuye4Yb2T6xjF3oiU+EGvKhL1nkkDstrjNYxbc+/jLTswM9
# sbKvkjh+0p2ALPVOVpEhNSXDOW5kf1O6nA+tGSOEy/S6A4aN91/w0FK/jJSHvMAh
# dCVfGCi2zCcoOCWYOUo2z3yxkq4cI6epZuxhH2rhKEmdX4jiJV3TIUs+UsS1Vz8k
# A/DRelsv1SPjcF0PUUZ3s/gA4bysAoJf28AVs70b1FVL5zmhD+kjSbwYuER8ReTB
# w3J64HLnJN+/RpnF78IcV9uDjexNSTCnq47f7Fufr/zdsGbiwZeBe+3W7UvnSSmn
# Eyimp31ngOaKYnhfsi+E11ecXL93KCjx7W3DKI8sj0A3T8HhhUSJxAlMxdSlQy90
# lfdu+HggWCwTXWCVmj5PM4TasIgX3p5O9JawvEagbJjS4NaIjAsCAwEAAaOCAe0w
# ggHpMBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQWBBRIbmTlUAXTgqoXNzcitW2o
# ynUClTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYD
# VR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBRyLToCMZBDuRQFTuHqp8cx0SOJNDBa
# BgNVHR8EUzBRME+gTaBLhklodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2Ny
# bC9wcm9kdWN0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3JsMF4GCCsG
# AQUFBwEBBFIwUDBOBggrBgEFBQcwAoZCaHR0cDovL3d3dy5taWNyb3NvZnQuY29t
# L3BraS9jZXJ0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3J0MIGfBgNV
# HSAEgZcwgZQwgZEGCSsGAQQBgjcuAzCBgzA/BggrBgEFBQcCARYzaHR0cDovL3d3
# dy5taWNyb3NvZnQuY29tL3BraW9wcy9kb2NzL3ByaW1hcnljcHMuaHRtMEAGCCsG
# AQUFBwICMDQeMiAdAEwAZQBnAGEAbABfAHAAbwBsAGkAYwB5AF8AcwB0AGEAdABl
# AG0AZQBuAHQALiAdMA0GCSqGSIb3DQEBCwUAA4ICAQBn8oalmOBUeRou09h0ZyKb
# C5YR4WOSmUKWfdJ5DJDBZV8uLD74w3LRbYP+vj/oCso7v0epo/Np22O/IjWll11l
# hJB9i0ZQVdgMknzSGksc8zxCi1LQsP1r4z4HLimb5j0bpdS1HXeUOeLpZMlEPXh6
# I/MTfaaQdION9MsmAkYqwooQu6SpBQyb7Wj6aC6VoCo/KmtYSWMfCWluWpiW5IP0
# wI/zRive/DvQvTXvbiWu5a8n7dDd8w6vmSiXmE0OPQvyCInWH8MyGOLwxS3OW560
# STkKxgrCxq2u5bLZ2xWIUUVYODJxJxp/sfQn+N4sOiBpmLJZiWhub6e3dMNABQam
# ASooPoI/E01mC8CzTfXhj38cbxV9Rad25UAqZaPDXVJihsMdYzaXht/a8/jyFqGa
# J+HNpZfQ7l1jQeNbB5yHPgZ3BtEGsXUfFL5hYbXw3MYbBL7fQccOKO7eZS/sl/ah
# XJbYANahRr1Z85elCUtIEJmAH9AAKcWxm6U/RXceNcbSoqKfenoi+kiVH6v7RyOA
# 9Z74v2u3S5fi63V4GuzqN5l5GEv/1rMjaHXmr/r8i+sLgOppO6/8MO0ETI7f33Vt
# Y5E90Z1WTk+/gFcioXgRMiF670EKsT/7qMykXcGhiJtXcVZOSEXAQsmbdlsKgEhr
# /Xmfwb1tbWrJUnMTDXpQzTGCGgowghoGAgEBMIGVMH4xCzAJBgNVBAYTAlVTMRMw
# EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVN
# aWNyb3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNp
# Z25pbmcgUENBIDIwMTECEzMAAAOvMEAOTKNNBUEAAAAAA68wDQYJYIZIAWUDBAIB
# BQCgga4wGQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEO
# MAwGCisGAQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEINsYAhNIRcljW3cQrqrjUNX8
# pYHerwFGD3fpROHnm9YUMEIGCisGAQQBgjcCAQwxNDAyoBSAEgBNAGkAYwByAG8A
# cwBvAGYAdKEagBhodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20wDQYJKoZIhvcNAQEB
# BQAEggEAa/llsGsbXJJtvvBZnUlJTAvpD4mxtOkGRHJxYWaipSn+2njJvHmLcLKw
# /dWSFTrKtrOTPv51GuGibePbXTfNFbuqfD4KnIsya+eh727vsewvGvepC249KiSk
# zPzcq6LTu9yzSDMQenCS4e9snAlfG/2t1resyZk+EfbrajRaDP4F8kfELovaHNPB
# typQbKZZhZ2b8L1YHbD/aogdmG6jeXbxwKXQuwWyVSG/IZBQ8ufUoVeIBb9wQ9iX
# WvUNT4qOOCAL9MUcLLsf9W+nfDNBUfY/rYWg4b4nQRceCWQkuveMfsWKOSw8pdol
# bm5oLoS07quyQgWRBpnpiJuzQMEc86GCF5QwgheQBgorBgEEAYI3AwMBMYIXgDCC
# F3wGCSqGSIb3DQEHAqCCF20wghdpAgEDMQ8wDQYJYIZIAWUDBAIBBQAwggFSBgsq
# hkiG9w0BCRABBKCCAUEEggE9MIIBOQIBAQYKKwYBBAGEWQoDATAxMA0GCWCGSAFl
# AwQCAQUABCDDrcGUVBJ/rIA3fCdcl/VrrqYUszFbaB1aGd73YyceFwIGZhfuDIgz
# GBMyMDI0MDQyNTE2MzQ0NS43NzFaMASAAgH0oIHRpIHOMIHLMQswCQYDVQQGEwJV
# UzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UE
# ChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSUwIwYDVQQLExxNaWNyb3NvZnQgQW1l
# cmljYSBPcGVyYXRpb25zMScwJQYDVQQLEx5uU2hpZWxkIFRTUyBFU046ODYwMy0w
# NUUwLUQ5NDcxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2Wg
# ghHqMIIHIDCCBQigAwIBAgITMwAAAfGzRfUn6MAW1gABAAAB8TANBgkqhkiG9w0B
# AQsFADB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UE
# BxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYD
# VQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDAeFw0yMzEyMDYxODQ1
# NTVaFw0yNTAzMDUxODQ1NTVaMIHLMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2Fz
# aGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENv
# cnBvcmF0aW9uMSUwIwYDVQQLExxNaWNyb3NvZnQgQW1lcmljYSBPcGVyYXRpb25z
# MScwJQYDVQQLEx5uU2hpZWxkIFRTUyBFU046ODYwMy0wNUUwLUQ5NDcxJTAjBgNV
# BAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2UwggIiMA0GCSqGSIb3DQEB
# AQUAA4ICDwAwggIKAoICAQCxulCZttIf8X97rW9/J+Q4Vg9PiugB1ya1/DRxxLW2
# hwy4QgtU3j5fV75ZKa6XTTQhW5ClkGl6gp1nd5VBsx4Jb+oU4PsMA2foe8gP9bQN
# PVxIHMJu6TYcrrn39Hddet2xkdqUhzzySXaPFqFMk2VifEfj+HR6JheNs2LLzm8F
# DJm+pBddPDLag/R+APIWHyftq9itwM0WP5Z0dfQyI4WlVeUS+votsPbWm+RKsH4F
# QNhzb0t/D4iutcfCK3/LK+xLmS6dmAh7AMKuEUl8i2kdWBDRcc+JWa21SCefx5SP
# hJEFgYhdGPAop3G1l8T33cqrbLtcFJqww4TQiYiCkdysCcnIF0ZqSNAHcfI9SAv3
# gfkyxqQNJJ3sTsg5GPRF95mqgbfQbkFnU17iYbRIPJqwgSLhyB833ZDgmzxbKmJm
# dDabbzS0yGhngHa6+gwVaOUqcHf9w6kwxMo+OqG3QZIcwd5wHECs5rAJZ6PIyFM7
# Ad2hRUFHRTi353I7V4xEgYGuZb6qFx6Pf44i7AjXbptUolDcVzYEdgLQSWiuFajS
# 6Xg3k7Cy8TiM5HPUK9LZInloTxuULSxJmJ7nTjUjOj5xwRmC7x2S/mxql8nvHSCN
# 1OED2/wECOot6MEe9bL3nzoKwO8TNlEStq5scd25GA0gMQO+qNXV/xTDOBTJ8zBc
# GQIDAQABo4IBSTCCAUUwHQYDVR0OBBYEFLy2xe59sCE0SjycqE5Erb4YrS1gMB8G
# A1UdIwQYMBaAFJ+nFV0AXmJdg/Tl0mWnG1M1GelyMF8GA1UdHwRYMFYwVKBSoFCG
# Tmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY3JsL01pY3Jvc29mdCUy
# MFRpbWUtU3RhbXAlMjBQQ0ElMjAyMDEwKDEpLmNybDBsBggrBgEFBQcBAQRgMF4w
# XAYIKwYBBQUHMAKGUGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2Vy
# dHMvTWljcm9zb2Z0JTIwVGltZS1TdGFtcCUyMFBDQSUyMDIwMTAoMSkuY3J0MAwG
# A1UdEwEB/wQCMAAwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwgwDgYDVR0PAQH/BAQD
# AgeAMA0GCSqGSIb3DQEBCwUAA4ICAQDhSEjSBFSCbJyl3U/QmFMW2eLPBknnlsfI
# D/7gTMvANEnhq08I9HHbbqiwqDEHSvARvKtL7j0znICYBbMrVSmvgDxU8jAGqMyi
# LoM80788So3+T6IZV//UZRJqBl4oM3bCIQgFGo0VTeQ6RzYL+t1zCUXmmpPmM4xc
# ScVFATXj5Tx7By4ShWUC7Vhm7picDiU5igGjuivRhxPvbpflbh/bsiE5tx5cuOJE
# JSG+uWcqByR7TC4cGvuavHSjk1iRXT/QjaOEeJoOnfesbOdvJrJdbm+leYLRI67N
# 3cd8B/suU21tRdgwOnTk2hOuZKs/kLwaX6NsAbUy9pKsDmTyoWnGmyTWBPiTb2rp
# 5ogo8Y8hMU1YQs7rHR5hqilEq88jF+9H8Kccb/1ismJTGnBnRMv68Ud2l5LFhOZ4
# nRtl4lHri+N1L8EBg7aE8EvPe8Ca9gz8sh2F4COTYd1PHce1ugLvvWW1+aOSpd8N
# nwEid4zgD79ZQxisJqyO4lMWMzAgEeFhUm40FshtzXudAsX5LoCil4rLbHfwYtGO
# pw9DVX3jXAV90tG9iRbcqjtt3vhW9T+L3fAZlMeraWfh7eUmPltMU8lEQOMelo/1
# ehkIGO7YZOHxUqeKpmF9QaW8LXTT090AHZ4k6g+tdpZFfCMotyG+E4XqN6ZWtKEB
# QiE3xL27BDCCB3EwggVZoAMCAQICEzMAAAAVxedrngKbSZkAAAAAABUwDQYJKoZI
# hvcNAQELBQAwgYgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAw
# DgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24x
# MjAwBgNVBAMTKU1pY3Jvc29mdCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAy
# MDEwMB4XDTIxMDkzMDE4MjIyNVoXDTMwMDkzMDE4MzIyNVowfDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNV
# BAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRp
# bWUtU3RhbXAgUENBIDIwMTAwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
# AQDk4aZM57RyIQt5osvXJHm9DtWC0/3unAcH0qlsTnXIyjVX9gF/bErg4r25Phdg
# M/9cT8dm95VTcVrifkpa/rg2Z4VGIwy1jRPPdzLAEBjoYH1qUoNEt6aORmsHFPPF
# dvWGUNzBRMhxXFExN6AKOG6N7dcP2CZTfDlhAnrEqv1yaa8dq6z2Nr41JmTamDu6
# GnszrYBbfowQHJ1S/rboYiXcag/PXfT+jlPP1uyFVk3v3byNpOORj7I5LFGc6XBp
# Dco2LXCOMcg1KL3jtIckw+DJj361VI/c+gVVmG1oO5pGve2krnopN6zL64NF50Zu
# yjLVwIYwXE8s4mKyzbnijYjklqwBSru+cakXW2dg3viSkR4dPf0gz3N9QZpGdc3E
# XzTdEonW/aUgfX782Z5F37ZyL9t9X4C626p+Nuw2TPYrbqgSUei/BQOj0XOmTTd0
# lBw0gg/wEPK3Rxjtp+iZfD9M269ewvPV2HM9Q07BMzlMjgK8QmguEOqEUUbi0b1q
# GFphAXPKZ6Je1yh2AuIzGHLXpyDwwvoSCtdjbwzJNmSLW6CmgyFdXzB0kZSU2LlQ
# +QuJYfM2BjUYhEfb3BvR/bLUHMVr9lxSUV0S2yW6r1AFemzFER1y7435UsSFF5PA
# PBXbGjfHCBUYP3irRbb1Hode2o+eFnJpxq57t7c+auIurQIDAQABo4IB3TCCAdkw
# EgYJKwYBBAGCNxUBBAUCAwEAATAjBgkrBgEEAYI3FQIEFgQUKqdS/mTEmr6CkTxG
# NSnPEP8vBO4wHQYDVR0OBBYEFJ+nFV0AXmJdg/Tl0mWnG1M1GelyMFwGA1UdIARV
# MFMwUQYMKwYBBAGCN0yDfQEBMEEwPwYIKwYBBQUHAgEWM2h0dHA6Ly93d3cubWlj
# cm9zb2Z0LmNvbS9wa2lvcHMvRG9jcy9SZXBvc2l0b3J5Lmh0bTATBgNVHSUEDDAK
# BggrBgEFBQcDCDAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMC
# AYYwDwYDVR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBTV9lbLj+iiXGJo0T2UkFvX
# zpoYxDBWBgNVHR8ETzBNMEugSaBHhkVodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20v
# cGtpL2NybC9wcm9kdWN0cy9NaWNSb29DZXJBdXRfMjAxMC0wNi0yMy5jcmwwWgYI
# KwYBBQUHAQEETjBMMEoGCCsGAQUFBzAChj5odHRwOi8vd3d3Lm1pY3Jvc29mdC5j
# b20vcGtpL2NlcnRzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNydDANBgkqhkiG
# 9w0BAQsFAAOCAgEAnVV9/Cqt4SwfZwExJFvhnnJL/Klv6lwUtj5OR2R4sQaTlz0x
# M7U518JxNj/aZGx80HU5bbsPMeTCj/ts0aGUGCLu6WZnOlNN3Zi6th542DYunKmC
# VgADsAW+iehp4LoJ7nvfam++Kctu2D9IdQHZGN5tggz1bSNU5HhTdSRXud2f8449
# xvNo32X2pFaq95W2KFUn0CS9QKC/GbYSEhFdPSfgQJY4rPf5KYnDvBewVIVCs/wM
# nosZiefwC2qBwoEZQhlSdYo2wh3DYXMuLGt7bj8sCXgU6ZGyqVvfSaN0DLzskYDS
# PeZKPmY7T7uG+jIa2Zb0j/aRAfbOxnT99kxybxCrdTDFNLB62FD+CljdQDzHVG2d
# Y3RILLFORy3BFARxv2T5JL5zbcqOCb2zAVdJVGTZc9d/HltEAY5aGZFrDZ+kKNxn
# GSgkujhLmm77IVRrakURR6nxt67I6IleT53S0Ex2tVdUCbFpAUR+fKFhbHP+Crvs
# QWY9af3LwUFJfn6Tvsv4O+S3Fb+0zj6lMVGEvL8CwYKiexcdFYmNcP7ntdAoGokL
# jzbaukz5m/8K6TT4JDVnK+ANuOaMmdbhIurwJ0I9JZTmdHRbatGePu1+oDEzfbzL
# 6Xu/OHBE0ZDxyKs6ijoIYn/ZcGNTTY3ugm2lBRDBcQZqELQdVTNYs6FwZvKhggNN
# MIICNQIBATCB+aGB0aSBzjCByzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hp
# bmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jw
# b3JhdGlvbjElMCMGA1UECxMcTWljcm9zb2Z0IEFtZXJpY2EgT3BlcmF0aW9uczEn
# MCUGA1UECxMeblNoaWVsZCBUU1MgRVNOOjg2MDMtMDVFMC1EOTQ3MSUwIwYDVQQD
# ExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNloiMKAQEwBwYFKw4DAhoDFQD7
# n7Bk4gsM2tbU/i+M3BtRnLj096CBgzCBgKR+MHwxCzAJBgNVBAYTAlVTMRMwEQYD
# VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1w
# IFBDQSAyMDEwMA0GCSqGSIb3DQEBCwUAAgUA6dTgTDAiGA8yMDI0MDQyNTEzNTk0
# MFoYDzIwMjQwNDI2MTM1OTQwWjB0MDoGCisGAQQBhFkKBAExLDAqMAoCBQDp1OBM
# AgEAMAcCAQACAhnNMAcCAQACAhNSMAoCBQDp1jHMAgEAMDYGCisGAQQBhFkKBAIx
# KDAmMAwGCisGAQQBhFkKAwKgCjAIAgEAAgMHoSChCjAIAgEAAgMBhqAwDQYJKoZI
# hvcNAQELBQADggEBAB3+2BIQ+5QNhlR/FpnbO7ZRVa0GEUCYZdatfND5AT0OeybJ
# Ao7USU8bYIh625p6i+2XAE3NkyZJ9YdDjzTLDdWBvY2GrLzi66rcCrNO5bFmAS1w
# /MS4Mwx/vFUUu2AqL0ogerXlVaiW9QSUKK9W0xPyEx4oOHYUmZqvlUwRsiSQNrQz
# SuygEc4I3D33i+GKgNuA07rx/MOH+VCEmW+fNHas2Y9L+w4bFhZsGjeuLJRMZC3B
# qkUvcu6fzGpZRXouOUqgcuO4kZqa5XBEm73inAno84k3jKTFgWtoiIUDJuUA+Y3P
# 7nM5H6kPO/iN4FqVFQI09L8LaslsWM/OjW4yTDsxggQNMIIECQIBATCBkzB8MQsw
# CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9u
# ZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNy
# b3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMAITMwAAAfGzRfUn6MAW1gABAAAB8TAN
# BglghkgBZQMEAgEFAKCCAUowGgYJKoZIhvcNAQkDMQ0GCyqGSIb3DQEJEAEEMC8G
# CSqGSIb3DQEJBDEiBCCjUA4fILCGTfjlUgs7zMXaqNjVXYJLRjAfLCq88V29qjCB
# +gYLKoZIhvcNAQkQAi8xgeowgecwgeQwgb0EINV3/T5hS7ijwao466RosB7wwEib
# t0a1P5EqIwEj9hF4MIGYMIGApH4wfDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldh
# c2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBD
# b3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBIDIw
# MTACEzMAAAHxs0X1J+jAFtYAAQAAAfEwIgQgez2VZNV79jt3XboGQdmOW5Q/+jKS
# ck2vsYS8iZLC8a8wDQYJKoZIhvcNAQELBQAEggIAas4TVhSeT3oZr69BVHBjzqae
# wYOH6bvlQG1i0HwOvAYNBxU0nWbK1Shlxu+iJFAFAlyUAiwmN0r3iSgqRRIwhnmY
# y37zOfVnTpQgUeKIKlRITnpoULStKNJfo5Y8RW5bQJcJHqF9m5DvgBvq7OEziKFI
# LWk6gP77nIr9aX0K4EZESwzU9PJKTfDidXFOQoTokyhUiVemcOwwynE33wHWMwGu
# fMno79amtnsARltqKAhgL06GpRyRmnVQ/J37/7IWnprQRWKZ8/tQZ6OMieKUxJqp
# ypHUgd0UlZZThdth9xs7HpdsSOfeXrUMBPzyUcq/Z0AS9dkrvBdDpSlGTXxrgaiR
# f8y23UparAUvjoyU+mPDrvkLoHSmkepukmiopwLg0uT7kk+7HvCTuW+iJlj8nG8H
# X01cjBwB93y3MkqkIP5WsTnIfouCn1i6xM9HzTnNot2Y82FaVe5plA0fq4gSW/Ri
# RZNPA2iXHSyIKhqLmrmNBJwQwn1ZHLtllZ2a1IZD6NOr1KPqo0XceOicYP+Wia4c
# C9sBtUZwER+d39dfWOm+VNQU6gRLRplEvoln7ezjG1BFv6yo78gbAVIaNpeyfJDj
# IR3DzXKBngwvq6CkQXlPMg1V6fdqFeSrZso3jCLNSJ7x4GMIRETgvkBIWPHnMihr
# TNcedezqU5+wj83JB6s=
# SIG # End signature block
